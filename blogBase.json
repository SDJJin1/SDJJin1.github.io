{"singlePage": [], "startSite": "", "filingNum": "", "onePageListNum": 15, "commentLabelColor": "#006b75", "yearColorList": ["#bc4c00", "#0969da", "#1f883d", "#A333D0"], "i18n": "CN", "themeMode": "manual", "dayTheme": "light", "nightTheme": "dark", "urlMode": "pinyin", "script": "", "style": "", "head": "", "indexScript": "", "indexStyle": "", "bottomText": "", "showPostSource": 1, "iconList": {}, "UTC": 8, "rssSplit": "sentence", "exlink": {}, "needComment": 1, "allHead": "", "title": "Blog Title", "subTitle": "Blog description", "avatarUrl": "https://github.githubassets.com/favicons/favicon.svg", "GMEEK_VERSION": "last", "postListJson": {"P1": {"htmlDir": "docs/post/Test.html", "labels": ["documentation"], "postTitle": "Test", "postUrl": "post/Test.html", "postSourceUrl": "https://github.com/SDJJin1/SDJJin1.github.io/issues/1", "commentNum": 0, "wordCount": 11, "description": "Hello World\u3002", "top": 0, "createdAt": 1764862401, "style": "", "script": "", "head": "", "ogImage": "https://github.githubassets.com/favicons/favicon.svg", "createdDate": "2025-12-04", "dateLabelColor": "#0969da"}, "P3": {"htmlDir": "docs/post/GAMES101 hw1.html", "labels": ["Games101"], "postTitle": "GAMES101 hw1", "postUrl": "post/GAMES101%20hw1.html", "postSourceUrl": "https://github.com/SDJJin1/SDJJin1.github.io/issues/3", "commentNum": 0, "wordCount": 1977, "description": "\u6839\u636e\u8bfe\u4e0a\u8bb2\u7684\u6c42\u6a21\u578b\u77e9\u9635\u7684\u65b9\u6cd5\n\n<img width='999' height='654' alt='Image' src='https://github.com/user-attachments/assets/66c8a127-94f3-4214-9559-352d19a612f4' />\n\n``` c++\nEigen::Matrix4f get_model_matrix(float rotation_angle)\n{\n    Eigen::Matrix4f model = Eigen::Matrix4f::Identity();\n    float arc1 = rotation_angle / 180.0 * acos(-1);\n    model << std::cos(arc1), -std::sin(arc1), 0, 0,\n            std::sin(arc1), std::cos(arc1), 0, 0,\n            0, 0, 1, 0,\n            0, 0, 0, 1;\n\n    return model;\n}\n```\n\n\u8981\u6c42\u6295\u5f71\u77e9\u9635\uff0c\u5c31\u8981\u5148\u5f97\u5230\u6b63\u4ea4\u77e9\u9635\uff0c\u7136\u540e\u6324\u538b\u6210\u6295\u5f71\u77e9\u9635\n\n<img width='1252' height='819' alt='Image' src='https://github.com/user-attachments/assets/74ec068e-2a5c-485f-9915-67671bb788ea' />\n\n\u6c42\u6b63\u4ea4\u77e9\u9635\u7684\u65b9\u6cd5\n\n<img width='1132' height='751' alt='Image' src='https://github.com/user-attachments/assets/c9abdbb9-46a1-4245-930e-9a55006aa629' />\n\n\u7531\u6b63\u4ea4\u77e9\u9635\u6324\u538b\u6210\u6295\u5f71\u77e9\u9635\n\n<img width='343' height='146' alt='Image' src='https://github.com/user-attachments/assets/ae19a871-24a7-46db-a9c3-335e8ae47138' />\n\n\u518d\u7531fov\u6c42\u5176\u4ed6\u53c2\u6570\n\n<img width='971' height='548' alt='Image' src='https://github.com/user-attachments/assets/65d17868-4d03-4e7c-b506-da25c6fdf0ba' />\n\n``` c++\nEigen::Matrix4f get_projection_matrix(float eye_fov, float aspect_ratio,\n                                      float zNear, float zFar)\n{\n    Eigen::Matrix4f projection = Eigen::Matrix4f::Identity();\n\n    float t = std::tan(eye_fov) * std::abs(zNear);\n    float b = t * -1;\n    float r = aspect_ratio * t;\n    float l = r * -1;\n\n    Eigen::Matrix4f ortho;\n    ortho << 2/ (r - l), 0, 0, 0,\n            0, 2/ (t - b), 0, 0,\n            0, 0, 2/ (zNear - zFar), 0,\n            0, 0, 0, 1;\n\n    Eigen::Matrix4f x;\n    x << 1, 0, 0, -((r + l) / 2),\n        0, 1, 0, -((t + b) / 2),\n        0, 0, 1, -((zNear + zFar)),\n        0, 0, 0, 1;\n    \n    ortho = ortho * x;\n\n    Eigen::Matrix4f persp;\n    persp << zNear, 0, 0, 0,\n            0, zNear, 0, 0,\n            0, 0, zNear, -1 * zNear * zFar,\n            0, 0, 1, 0;\n\n    projection = ortho * persp;\n\n    return projection;\n}\n```\u3002", "top": 0, "createdAt": 1769003677, "style": "", "script": "", "head": "", "ogImage": "https://github.githubassets.com/favicons/favicon.svg", "createdDate": "2026-01-21", "dateLabelColor": "#1f883d"}, "P4": {"htmlDir": "docs/post/GAMES101 hw2.html", "labels": ["Games101"], "postTitle": "GAMES101 hw2", "postUrl": "post/GAMES101%20hw2.html", "postSourceUrl": "https://github.com/SDJJin1/SDJJin1.github.io/issues/4", "commentNum": 0, "wordCount": 2029, "description": "\u9996\u5148\u8981\u5224\u65ad\u70b9\u5728\u4e09\u89d2\u5f62\u5185\n\n<img width='762' height='480' alt='Image' src='https://github.com/user-attachments/assets/9396a6dd-1e88-4825-b61a-06609b5e890a' />\n\n``` c++\nstatic bool sameSide(Vector3f p, Vector3f a, Vector3f b, Vector3f c)\n{\n    Vector3f ab = b - a;\n    Vector3f ac = c - a;\n    Vector3f ap = p - a;\n    return (ab.cross(ac)).dot(ab.cross(ap)) >= 0;\n}\n\n\nstatic bool insideTriangle(int x, int y, const Vector3f* _v)\n{   \n    Vector3f p = {x, y, 1};\n\n    return sameSide(p, _v[0], _v[1], _v[2]) &&\n           sameSide(p, _v[1], _v[2], _v[0]) &&\n           sameSide(p, _v[2], _v[0], _v[1]);\n\n}\n```\n\n<img width='780' height='478' alt='Image' src='https://github.com/user-attachments/assets/902607b6-b3cb-4ef1-9810-aad9c87a159c' />\n\n``` c++\nvoid rst::rasterizer::rasterize_triangle(const Triangle& t) {\n    auto v = t.toVector4();\n\n    int minx = INT_MAX;\n    int maxx = INT_MIN;\n    int miny = INT_MAX;\n    int maxy = INT_MIN;\n\n    for(auto& i : v)\n    {\n        minx = i.x() < minx ? i.x() : minx;\n        miny = i.y() < miny ? i.y() : miny;\n        maxx = i.x() > maxx ? i.x() : maxx;\n        maxy = i.y() > maxy ? i.y() : maxy;\n    }\n    \n    for(int i = minx; i <= maxx; i++)\n    {\n        for(int j = miny; j <= maxy; j++)\n        {\n            float x = i + 0.5f;\n            float y = j + 0.5f;\n\n            if(insideTriangle(x, y, t.v))\n            {\n                auto[alpha, beta, gamma] = computeBarycentric2D(x, y, t.v);\n                float w_reciprocal = 1.0/(alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w());\n                float z_interpolated = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w();\n                z_interpolated *= w_reciprocal;\n                \n                int index = get_index(i, j);\n                if(z_interpolated < depth_buf[index])\n                {\n                    depth_buf[index] = z_interpolated;\n                    set_pixel(Eigen::Vector3f(i, j, z_interpolated), t.getColor());\n                }\n            }\n        }\n    }\n}\n```\u3002", "top": 0, "createdAt": 1769088330, "style": "", "script": "", "head": "", "ogImage": "https://github.githubassets.com/favicons/favicon.svg", "createdDate": "2026-01-22", "dateLabelColor": "#1f883d"}, "P5": {"htmlDir": "docs/post/GAMES101 hw3.html", "labels": ["Games101"], "postTitle": "GAMES101 hw3", "postUrl": "post/GAMES101%20hw3.html", "postSourceUrl": "https://github.com/SDJJin1/SDJJin1.github.io/issues/5", "commentNum": 0, "wordCount": 10853, "description": "hw3\u548chw2\u5728rasterize_triangle\u51fd\u6570\u4e0a\u7684\u533a\u522b\u662f\u9700\u8981\u81ea\u5df1\u8ba1\u7b97\u63d2\u503c\n\n``` c++\nvoid rst::rasterizer::rasterize_triangle(const Triangle& t, const std::array<Eigen::Vector3f, 3>& view_pos) \n{\n    auto v = t.toVector4();\n\n    int minx = INT_MAX;\n    int maxx = INT_MIN;\n    int miny = INT_MAX;\n    int maxy = INT_MIN;\n\n    for(auto& i : v)\n    {\n        minx = i.x() < minx ? i.x() : minx;\n        miny = i.y() < miny ? i.y() : miny;\n        maxx = i.x() > maxx ? i.x() : maxx;\n        maxy = i.y() > maxy ? i.y() : maxy;\n    }\n\n    for(int i = minx; i <= maxx; i++)\n    {\n        for(int j = miny; j <= maxy; j++)\n        {\n            float x = i + 0.5f;\n            float y = j + 0.5f;\n\n            if(insideTriangle(x, y, t.v))\n            {\n                auto[alpha, beta, gamma] = computeBarycentric2D(x, y, t.v);\n                float Z = 1.0 / (alpha / v[0].w() + beta / v[1].w() + gamma/v[2].w());\n    \t\t\tfloat zp = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w();\n    \t\t    zp *= Z;\n                \n                int index = get_index(i, j);\n                if(zp < depth_buf[index])\n                {\n                    auto interpolated_color = interpolate(alpha, beta, gamma, t.color[0], t.color[1], t.color[2], 1);\n                    auto interpolated_normal = interpolate(alpha, beta, gamma, t.normal[0], t.normal[1], t.normal[2], 1).normalized();\n                    auto interpolated_texcoords = interpolate(alpha, beta, gamma, t.tex_coords[0], t.tex_coords[1], t.tex_coords[2], 1);\n    \t\t\t    auto interpolated_shadingcoords = interpolate(alpha, beta, gamma, view_pos[0], view_pos[1], view_pos[2], 1);\n                    \n                    fragment_shader_payload payload(interpolated_color, interpolated_normal.normalized(), interpolated_texcoords, texture ? &*texture : nullptr);\n                    payload.view_pos = interpolated_shadingcoords;\n\t\t\t  depth_buf[index] = zp;\n                    auto pixel_color = fragment_shader(payload);\n\n                    set_pixel(Eigen::Vector2i(i, j), pixel_color);\n                }\n            }\n        }\n    }\n}\n```\n\n\u5b8c\u6210\u540e\u5c31\u53ef\u4ee5\u5f97\u5230\n\n<img width='700' height='700' alt='Image' src='https://github.com/user-attachments/assets/708b1b64-2b6d-4cc7-995f-efd79ce57af9' />\n\nBlinn-Phong\u6a21\u578b\u7684\u516c\u5f0f\n\n<img width='1003' height='633' alt='Image' src='https://github.com/user-attachments/assets/a78e832d-0622-47b5-a728-3a2e3745d473' />\n\n``` c++\nEigen::Vector3f phong_fragment_shader(const fragment_shader_payload& payload)\n{\n    Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005);\n    Eigen::Vector3f kd = payload.color;\n    Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937);\n\n    auto l1 = light{{20, 20, 20}, {500, 500, 500}};\n    auto l2 = light{{-20, 20, 0}, {500, 500, 500}};\n\n    std::vector<light> lights = {l1, l2};\n    Eigen::Vector3f amb_light_intensity{10, 10, 10};\n    Eigen::Vector3f eye_pos{0, 0, 10};\n\n    float p = 150;\n\n    Eigen::Vector3f color = payload.color;\n    Eigen::Vector3f point = payload.view_pos;\n    Eigen::Vector3f normal = payload.normal;\n\n    Eigen::Vector3f result_color = {0, 0, 0};\n    for (auto& light : lights)\n    {\n        Eigen::Vector3f light_direction = (light.position - point).normalized();\n        Eigen::Vector3f view_direction = (eye_pos - point).normalized();\n        Eigen::Vector3f half_vector = (light_direction + view_direction).normalized();\n\n        float reflection_intensity = std::max(0.0f, half_vector.dot(normal));\n\n        float light_intensity_attenuation = (light.position - point).dot(light.position - point);\n\n        Eigen::Vector3f diffuse_reflection = kd.cwiseProduct(light.intensity / light_intensity_attenuation);\n        diffuse_reflection *= reflection_intensity;\n\n        Eigen::Vector3f high_lights = ks.cwiseProduct(light.intensity / light_intensity_attenuation);\n        high_lights *= std::pow(reflection_intensity, p);\n\n        result_color += (diffuse_reflection + high_lights);\n        \n    }\n\n    Eigen::Vector3f ambient_light_reflection = ka.cwiseProduct(amb_light_intensity);\n\n    result_color += ambient_light_reflection;\n\n    return result_color * 255.f;\n}\n```\n\u5c31\u53ef\u4ee5\u5f97\u5230\n\n<img width='700' height='700' alt='Image' src='https://github.com/user-attachments/assets/ce183f1d-4fcf-4a16-9dae-bff3e108d667' />\n\n\u6309\u9898\u76ee\u7684\u8981\u6c42\uff0c\u5c06\u7eb9\u7406\u989c\u8272\u89c6\u4e3a\u516c\u5f0f\u4e2d\u7684kd\n``` c++\nEigen::Vector3f texture_fragment_shader(const fragment_shader_payload& payload)\n{\n    Eigen::Vector3f return_color = {0, 0, 0};\n    if (payload.texture)\n    {\n     return_color = payload.texture->getColor(payload.tex_coords.x(), payload.tex_coords.y());\n\n    }\n    Eigen::Vector3f texture_color;\n    texture_color << return_color.x(), return_color.y(), return_color.z();\n\n    Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005);\n    Eigen::Vector3f kd = texture_color / 255.f;\n    Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937);\n\n    auto l1 = light{{20, 20, 20}, {500, 500, 500}};\n    auto l2 = light{{-20, 20, 0}, {500, 500, 500}};\n\n    std::vector<light> lights = {l1, l2};\n    Eigen::Vector3f amb_light_intensity{10, 10, 10};\n    Eigen::Vector3f eye_pos{0, 0, 10};\n\n    float p = 150;\n\n    Eigen::Vector3f color = texture_color;\n    Eigen::Vector3f point = payload.view_pos;\n    Eigen::Vector3f normal = payload.normal;\n\n    Eigen::Vector3f result_color = {0, 0, 0};\n\n    for (auto& light : lights)\n    {\n        Eigen::Vector3f light_direction = (light.position - point).normalized();\n        Eigen::Vector3f view_direction = (eye_pos - point).normalized();\n        Eigen::Vector3f half_vector = (light_direction + view_direction).normalized();\n\n        float reflection_intensity = std::max(0.0f, half_vector.dot(normal));\n\n        float light_intensity_attenuation = (light.position - point).dot(light.position - point);\n\n        Eigen::Vector3f diffuse_reflection = kd.cwiseProduct(light.intensity / light_intensity_attenuation);\n        diffuse_reflection *= reflection_intensity;\n\n        Eigen::Vector3f high_lights = ks.cwiseProduct(light.intensity / light_intensity_attenuation);\n        high_lights *= std::pow(reflection_intensity, p);\n\n        result_color += (diffuse_reflection + high_lights);\n    }\n        Eigen::Vector3f ambient_light_reflection = ka.cwiseProduct(amb_light_intensity);\n\n        result_color += ambient_light_reflection;\n\n    return result_color * 255.f;\n}\n```\n\n<img width='700' height='700' alt='Image' src='https://github.com/user-attachments/assets/b006f374-e3bd-4c85-84d8-f5c362f1c4e9' />\n\nbump\n``` c++\nEigen::Vector3f bump_fragment_shader(const fragment_shader_payload& payload)\n{\n    \n    Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005);\n    Eigen::Vector3f kd = payload.color;\n    Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937);\n\n    auto l1 = light{{20, 20, 20}, {500, 500, 500}};\n    auto l2 = light{{-20, 20, 0}, {500, 500, 500}};\n\n    std::vector<light> lights = {l1, l2};\n    Eigen::Vector3f amb_light_intensity{10, 10, 10};\n    Eigen::Vector3f eye_pos{0, 0, 10};\n\n    float p = 150;\n\n    Eigen::Vector3f color = payload.color; \n    Eigen::Vector3f point = payload.view_pos;\n    Eigen::Vector3f normal = payload.normal;\n\n\n    float kh = 0.2, kn = 0.1;\n\n \n    float x = normal.x();\n    float y = normal.y();\n    float z = normal.z();\n    Eigen::Vector3f t = {-x*y/sqrt(x*x+z*z),sqrt(x*x+z*z),-z*y/sqrt(x*x+z*z)};\n    Eigen::Vector3f b = normal.cross(t);\n    Eigen::Matrix3f TBN;\n    TBN << t.x(), b.x(), normal.x(), t.y(), b.y(), normal.y(), t.z(), b.z(), normal.z();\n    float u = payload.tex_coords.x();\n    float v = payload.tex_coords.y();\n    float w = payload.texture->width;\n    float h = payload.texture->height;\n    float dU = kh * kn *(payload.texture->getColor(u + 1.0 / w, v).norm() - payload.texture->getColor(u, v).norm());\n    float dV = kh * kn *(payload.texture->getColor(u, v + 1.0 / h).norm() - payload.texture->getColor(u, v).norm());\n\n    Eigen::Vector3f ln = {-dU, -dV, 1};\n    normal = (TBN * ln).normalized();\n\n    Eigen::Vector3f result_color = {0, 0, 0};\n    result_color = normal;\n\n    return result_color * 255.f;\n}\n```\n<img width='700' height='700' alt='Image' src='https://github.com/user-attachments/assets/cc0e7179-98de-41f4-bd74-f0cc7bac9d1c' />\n\ndisplacement\n``` c++\nEigen::Vector3f displacement_fragment_shader(const fragment_shader_payload& payload)\n{\n    \n    Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005);\n    Eigen::Vector3f kd = payload.color;\n    Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937);\n\n    auto l1 = light{{20, 20, 20}, {500, 500, 500}};\n    auto l2 = light{{-20, 20, 0}, {500, 500, 500}};\n\n    std::vector<light> lights = {l1, l2};\n    Eigen::Vector3f amb_light_intensity{10, 10, 10};\n    Eigen::Vector3f eye_pos{0, 0, 10};\n\n    float p = 150;\n\n    Eigen::Vector3f color = payload.color; \n    Eigen::Vector3f point = payload.view_pos;\n    Eigen::Vector3f normal = payload.normal;\n\n    float kh = 0.2, kn = 0.1;\n    \n    float x = normal.x();\n    float y = normal.y();\n    float z = normal.z();\n    Eigen::Vector3f t = {-x*y/sqrt(x*x+z*z),sqrt(x*x+z*z),-z*y/sqrt(x*x+z*z)};\n    Eigen::Vector3f b = normal.cross(t);\n    Eigen::Matrix3f TBN;\n    TBN << t.x(), b.x(), normal.x(), t.y(), b.y(), normal.y(), t.z(), b.z(), normal.z();\n    float u = payload.tex_coords.x();\n    float v = payload.tex_coords.y();\n    float w = payload.texture->width;\n    float h = payload.texture->height;\n    float dU = kh * kn *(payload.texture->getColor(u + 1.0 / w, v).norm() - payload.texture->getColor(u, v).norm());\n    float dV = kh * kn *(payload.texture->getColor(u, v + 1.0 / h).norm() - payload.texture->getColor(u, v).norm());\n\n    Eigen::Vector3f ln = {-dU, -dV, 1};\n    normal = (TBN * ln).normalized();\n\n\n    Eigen::Vector3f result_color = {0, 0, 0};\n\n    for (auto& light : lights)\n    {\n        Eigen::Vector3f light_direction = (light.position - point).normalized();\n        Eigen::Vector3f view_direction = (eye_pos - point).normalized();\n        Eigen::Vector3f half_vector = (light_direction + view_direction).normalized();\n\n        float reflection_intensity = std::max(0.0f, half_vector.dot(normal));\n\n        float light_intensity_attenuation = (light.position - point).dot(light.position - point);\n\n        Eigen::Vector3f diffuse_reflection = kd.cwiseProduct(light.intensity / light_intensity_attenuation);\n        diffuse_reflection *= reflection_intensity;\n\n        Eigen::Vector3f high_lights = ks.cwiseProduct(light.intensity / light_intensity_attenuation);\n        high_lights *= std::pow(reflection_intensity, p);\n\n        result_color += (diffuse_reflection + high_lights);\n\n\n    }\n\n    Eigen::Vector3f ambient_light_reflection = ka.cwiseProduct(amb_light_intensity);\n\n    result_color += ambient_light_reflection;\n    return result_color * 255.f;\n}\n```\n\n<img width='700' height='700' alt='Image' src='https://github.com/user-attachments/assets/88b7701e-5797-4bb2-aa3f-ee47fd00b165' />\u3002", "top": 0, "createdAt": 1769089684, "style": "", "script": "", "head": "", "ogImage": "https://github.githubassets.com/favicons/favicon.svg", "createdDate": "2026-01-22", "dateLabelColor": "#1f883d"}, "P6": {"htmlDir": "docs/post/GAMES101 hw3.html", "labels": ["Games101"], "postTitle": "GAMES101 hw3", "postUrl": "post/GAMES101%20hw3.html", "postSourceUrl": "https://github.com/SDJJin1/SDJJin1.github.io/issues/6", "commentNum": 0, "wordCount": 10853, "description": "hw3\u548chw2\u5728rasterize_triangle\u51fd\u6570\u4e0a\u7684\u533a\u522b\u662f\u9700\u8981\u81ea\u5df1\u8ba1\u7b97\u63d2\u503c\n\n``` c++\nvoid rst::rasterizer::rasterize_triangle(const Triangle& t, const std::array<Eigen::Vector3f, 3>& view_pos) \n{\n    auto v = t.toVector4();\n\n    int minx = INT_MAX;\n    int maxx = INT_MIN;\n    int miny = INT_MAX;\n    int maxy = INT_MIN;\n\n    for(auto& i : v)\n    {\n        minx = i.x() < minx ? i.x() : minx;\n        miny = i.y() < miny ? i.y() : miny;\n        maxx = i.x() > maxx ? i.x() : maxx;\n        maxy = i.y() > maxy ? i.y() : maxy;\n    }\n\n    for(int i = minx; i <= maxx; i++)\n    {\n        for(int j = miny; j <= maxy; j++)\n        {\n            float x = i + 0.5f;\n            float y = j + 0.5f;\n\n            if(insideTriangle(x, y, t.v))\n            {\n                auto[alpha, beta, gamma] = computeBarycentric2D(x, y, t.v);\n                float Z = 1.0 / (alpha / v[0].w() + beta / v[1].w() + gamma/v[2].w());\n    \t\t\tfloat zp = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w();\n    \t\t    zp *= Z;\n                \n                int index = get_index(i, j);\n                if(zp < depth_buf[index])\n                {\n                    auto interpolated_color = interpolate(alpha, beta, gamma, t.color[0], t.color[1], t.color[2], 1);\n                    auto interpolated_normal = interpolate(alpha, beta, gamma, t.normal[0], t.normal[1], t.normal[2], 1).normalized();\n                    auto interpolated_texcoords = interpolate(alpha, beta, gamma, t.tex_coords[0], t.tex_coords[1], t.tex_coords[2], 1);\n    \t\t\t    auto interpolated_shadingcoords = interpolate(alpha, beta, gamma, view_pos[0], view_pos[1], view_pos[2], 1);\n                    \n                    fragment_shader_payload payload(interpolated_color, interpolated_normal.normalized(), interpolated_texcoords, texture ? &*texture : nullptr);\n                    payload.view_pos = interpolated_shadingcoords;\n\t\t\t  depth_buf[index] = zp;\n                    auto pixel_color = fragment_shader(payload);\n\n                    set_pixel(Eigen::Vector2i(i, j), pixel_color);\n                }\n            }\n        }\n    }\n}\n```\n\n\u5b8c\u6210\u540e\u5c31\u53ef\u4ee5\u5f97\u5230\n\n<img width='700' height='700' alt='Image' src='https://github.com/user-attachments/assets/708b1b64-2b6d-4cc7-995f-efd79ce57af9' />\n\nBlinn-Phong\u6a21\u578b\u7684\u516c\u5f0f\n\n<img width='1003' height='633' alt='Image' src='https://github.com/user-attachments/assets/a78e832d-0622-47b5-a728-3a2e3745d473' />\n\n``` c++\nEigen::Vector3f phong_fragment_shader(const fragment_shader_payload& payload)\n{\n    Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005);\n    Eigen::Vector3f kd = payload.color;\n    Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937);\n\n    auto l1 = light{{20, 20, 20}, {500, 500, 500}};\n    auto l2 = light{{-20, 20, 0}, {500, 500, 500}};\n\n    std::vector<light> lights = {l1, l2};\n    Eigen::Vector3f amb_light_intensity{10, 10, 10};\n    Eigen::Vector3f eye_pos{0, 0, 10};\n\n    float p = 150;\n\n    Eigen::Vector3f color = payload.color;\n    Eigen::Vector3f point = payload.view_pos;\n    Eigen::Vector3f normal = payload.normal;\n\n    Eigen::Vector3f result_color = {0, 0, 0};\n    for (auto& light : lights)\n    {\n        Eigen::Vector3f light_direction = (light.position - point).normalized();\n        Eigen::Vector3f view_direction = (eye_pos - point).normalized();\n        Eigen::Vector3f half_vector = (light_direction + view_direction).normalized();\n\n        float reflection_intensity = std::max(0.0f, half_vector.dot(normal));\n\n        float light_intensity_attenuation = (light.position - point).dot(light.position - point);\n\n        Eigen::Vector3f diffuse_reflection = kd.cwiseProduct(light.intensity / light_intensity_attenuation);\n        diffuse_reflection *= reflection_intensity;\n\n        Eigen::Vector3f high_lights = ks.cwiseProduct(light.intensity / light_intensity_attenuation);\n        high_lights *= std::pow(reflection_intensity, p);\n\n        result_color += (diffuse_reflection + high_lights);\n        \n    }\n\n    Eigen::Vector3f ambient_light_reflection = ka.cwiseProduct(amb_light_intensity);\n\n    result_color += ambient_light_reflection;\n\n    return result_color * 255.f;\n}\n```\n\u5c31\u53ef\u4ee5\u5f97\u5230\n\n<img width='700' height='700' alt='Image' src='https://github.com/user-attachments/assets/ce183f1d-4fcf-4a16-9dae-bff3e108d667' />\n\n\u6309\u9898\u76ee\u7684\u8981\u6c42\uff0c\u5c06\u7eb9\u7406\u989c\u8272\u89c6\u4e3a\u516c\u5f0f\u4e2d\u7684kd\n``` c++\nEigen::Vector3f texture_fragment_shader(const fragment_shader_payload& payload)\n{\n    Eigen::Vector3f return_color = {0, 0, 0};\n    if (payload.texture)\n    {\n     return_color = payload.texture->getColor(payload.tex_coords.x(), payload.tex_coords.y());\n\n    }\n    Eigen::Vector3f texture_color;\n    texture_color << return_color.x(), return_color.y(), return_color.z();\n\n    Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005);\n    Eigen::Vector3f kd = texture_color / 255.f;\n    Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937);\n\n    auto l1 = light{{20, 20, 20}, {500, 500, 500}};\n    auto l2 = light{{-20, 20, 0}, {500, 500, 500}};\n\n    std::vector<light> lights = {l1, l2};\n    Eigen::Vector3f amb_light_intensity{10, 10, 10};\n    Eigen::Vector3f eye_pos{0, 0, 10};\n\n    float p = 150;\n\n    Eigen::Vector3f color = texture_color;\n    Eigen::Vector3f point = payload.view_pos;\n    Eigen::Vector3f normal = payload.normal;\n\n    Eigen::Vector3f result_color = {0, 0, 0};\n\n    for (auto& light : lights)\n    {\n        Eigen::Vector3f light_direction = (light.position - point).normalized();\n        Eigen::Vector3f view_direction = (eye_pos - point).normalized();\n        Eigen::Vector3f half_vector = (light_direction + view_direction).normalized();\n\n        float reflection_intensity = std::max(0.0f, half_vector.dot(normal));\n\n        float light_intensity_attenuation = (light.position - point).dot(light.position - point);\n\n        Eigen::Vector3f diffuse_reflection = kd.cwiseProduct(light.intensity / light_intensity_attenuation);\n        diffuse_reflection *= reflection_intensity;\n\n        Eigen::Vector3f high_lights = ks.cwiseProduct(light.intensity / light_intensity_attenuation);\n        high_lights *= std::pow(reflection_intensity, p);\n\n        result_color += (diffuse_reflection + high_lights);\n    }\n        Eigen::Vector3f ambient_light_reflection = ka.cwiseProduct(amb_light_intensity);\n\n        result_color += ambient_light_reflection;\n\n    return result_color * 255.f;\n}\n```\n\n<img width='700' height='700' alt='Image' src='https://github.com/user-attachments/assets/b006f374-e3bd-4c85-84d8-f5c362f1c4e9' />\n\nbump\n``` c++\nEigen::Vector3f bump_fragment_shader(const fragment_shader_payload& payload)\n{\n    \n    Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005);\n    Eigen::Vector3f kd = payload.color;\n    Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937);\n\n    auto l1 = light{{20, 20, 20}, {500, 500, 500}};\n    auto l2 = light{{-20, 20, 0}, {500, 500, 500}};\n\n    std::vector<light> lights = {l1, l2};\n    Eigen::Vector3f amb_light_intensity{10, 10, 10};\n    Eigen::Vector3f eye_pos{0, 0, 10};\n\n    float p = 150;\n\n    Eigen::Vector3f color = payload.color; \n    Eigen::Vector3f point = payload.view_pos;\n    Eigen::Vector3f normal = payload.normal;\n\n\n    float kh = 0.2, kn = 0.1;\n\n \n    float x = normal.x();\n    float y = normal.y();\n    float z = normal.z();\n    Eigen::Vector3f t = {-x*y/sqrt(x*x+z*z),sqrt(x*x+z*z),-z*y/sqrt(x*x+z*z)};\n    Eigen::Vector3f b = normal.cross(t);\n    Eigen::Matrix3f TBN;\n    TBN << t.x(), b.x(), normal.x(), t.y(), b.y(), normal.y(), t.z(), b.z(), normal.z();\n    float u = payload.tex_coords.x();\n    float v = payload.tex_coords.y();\n    float w = payload.texture->width;\n    float h = payload.texture->height;\n    float dU = kh * kn *(payload.texture->getColor(u + 1.0 / w, v).norm() - payload.texture->getColor(u, v).norm());\n    float dV = kh * kn *(payload.texture->getColor(u, v + 1.0 / h).norm() - payload.texture->getColor(u, v).norm());\n\n    Eigen::Vector3f ln = {-dU, -dV, 1};\n    normal = (TBN * ln).normalized();\n\n    Eigen::Vector3f result_color = {0, 0, 0};\n    result_color = normal;\n\n    return result_color * 255.f;\n}\n```\n<img width='700' height='700' alt='Image' src='https://github.com/user-attachments/assets/cc0e7179-98de-41f4-bd74-f0cc7bac9d1c' />\n\ndisplacement\n``` c++\nEigen::Vector3f displacement_fragment_shader(const fragment_shader_payload& payload)\n{\n    \n    Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005);\n    Eigen::Vector3f kd = payload.color;\n    Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937);\n\n    auto l1 = light{{20, 20, 20}, {500, 500, 500}};\n    auto l2 = light{{-20, 20, 0}, {500, 500, 500}};\n\n    std::vector<light> lights = {l1, l2};\n    Eigen::Vector3f amb_light_intensity{10, 10, 10};\n    Eigen::Vector3f eye_pos{0, 0, 10};\n\n    float p = 150;\n\n    Eigen::Vector3f color = payload.color; \n    Eigen::Vector3f point = payload.view_pos;\n    Eigen::Vector3f normal = payload.normal;\n\n    float kh = 0.2, kn = 0.1;\n    \n    float x = normal.x();\n    float y = normal.y();\n    float z = normal.z();\n    Eigen::Vector3f t = {-x*y/sqrt(x*x+z*z),sqrt(x*x+z*z),-z*y/sqrt(x*x+z*z)};\n    Eigen::Vector3f b = normal.cross(t);\n    Eigen::Matrix3f TBN;\n    TBN << t.x(), b.x(), normal.x(), t.y(), b.y(), normal.y(), t.z(), b.z(), normal.z();\n    float u = payload.tex_coords.x();\n    float v = payload.tex_coords.y();\n    float w = payload.texture->width;\n    float h = payload.texture->height;\n    float dU = kh * kn *(payload.texture->getColor(u + 1.0 / w, v).norm() - payload.texture->getColor(u, v).norm());\n    float dV = kh * kn *(payload.texture->getColor(u, v + 1.0 / h).norm() - payload.texture->getColor(u, v).norm());\n\n    Eigen::Vector3f ln = {-dU, -dV, 1};\n    normal = (TBN * ln).normalized();\n\n\n    Eigen::Vector3f result_color = {0, 0, 0};\n\n    for (auto& light : lights)\n    {\n        Eigen::Vector3f light_direction = (light.position - point).normalized();\n        Eigen::Vector3f view_direction = (eye_pos - point).normalized();\n        Eigen::Vector3f half_vector = (light_direction + view_direction).normalized();\n\n        float reflection_intensity = std::max(0.0f, half_vector.dot(normal));\n\n        float light_intensity_attenuation = (light.position - point).dot(light.position - point);\n\n        Eigen::Vector3f diffuse_reflection = kd.cwiseProduct(light.intensity / light_intensity_attenuation);\n        diffuse_reflection *= reflection_intensity;\n\n        Eigen::Vector3f high_lights = ks.cwiseProduct(light.intensity / light_intensity_attenuation);\n        high_lights *= std::pow(reflection_intensity, p);\n\n        result_color += (diffuse_reflection + high_lights);\n\n\n    }\n\n    Eigen::Vector3f ambient_light_reflection = ka.cwiseProduct(amb_light_intensity);\n\n    result_color += ambient_light_reflection;\n    return result_color * 255.f;\n}\n```\n\n<img width='700' height='700' alt='Image' src='https://github.com/user-attachments/assets/88b7701e-5797-4bb2-aa3f-ee47fd00b165' />\u3002", "top": 0, "createdAt": 1769180334, "style": "", "script": "", "head": "", "ogImage": "https://github.githubassets.com/favicons/favicon.svg", "createdDate": "2026-01-23", "dateLabelColor": "#1f883d"}, "P7": {"htmlDir": "docs/post/GAMES101 hw4.html", "labels": ["Games101"], "postTitle": "GAMES101 hw4", "postUrl": "post/GAMES101%20hw4.html", "postSourceUrl": "https://github.com/SDJJin1/SDJJin1.github.io/issues/7", "commentNum": 0, "wordCount": 1012, "description": "\u6839\u636e\u8bfe\u4e0a\u8bb2\u7684\n\n<img width='990' height='614' alt='Image' src='https://github.com/user-attachments/assets/86c183bf-26e9-449a-83d8-eab3299f9a12' />\n\n``` c++\ncv::Point2f recursive_bezier(const std::vector<cv::Point2f> &control_points, float t) \n{\n    if (control_points.size() == 2)\n    {\n        return (1 - t) * control_points[0] + t * control_points[1];\n    }\n\n    std::vector<cv::Point2f> new_control_points;\n\n    for (int i = 0; i < control_points.size() - 1; i++)\n    {\n        new_control_points.push_back((1 - t) * control_points[i] + t * control_points[i+1]);\n    }\n    \n    return recursive_bezier(new_control_points, t);\n\n}\n\nvoid bezier(const std::vector<cv::Point2f> &control_points, cv::Mat &window) \n{\n    for (float t = 0; t <= 1; t += 0.001)\n    {\n        auto point = recursive_bezier(control_points, t);\n        window.at<cv::Vec3b>(point.y, point.x)[1] = 255;\n    }\n}\n```\n\n<img width='700' height='700' alt='Image' src='https://github.com/user-attachments/assets/08601d97-9ad4-4bda-9cf6-49450f29be63' />\u3002", "top": 0, "createdAt": 1769181686, "style": "", "script": "", "head": "", "ogImage": "https://github.githubassets.com/favicons/favicon.svg", "createdDate": "2026-01-23", "dateLabelColor": "#1f883d"}, "P8": {"htmlDir": "docs/post/GAMES101 hw5.html", "labels": ["Games101"], "postTitle": "GAMES101 hw5", "postUrl": "post/GAMES101%20hw5.html", "postSourceUrl": "https://github.com/SDJJin1/SDJJin1.github.io/issues/8", "commentNum": 0, "wordCount": 2338, "description": "``` c++\nvoid Renderer::Render(const Scene& scene)\n{\n    std::vector<Vector3f> framebuffer(scene.width * scene.height);\n\n    float scale = std::tan(deg2rad(scene.fov * 0.5f));\n    float imageAspectRatio = scene.width / (float)scene.height;\n\n    // Use this variable as the eye position to start your rays.\n    Vector3f eye_pos(0);\n    int m = 0;\n    for (int j = 0; j < scene.height; ++j)\n    {\n        for (int i = 0; i < scene.width; ++i)\n        {\n            // generate primary ray direction\n            float x, world_scene_width;\n            float y, world_scene_height;\n            world_scene_width = 1 * scale * 2 * imageAspectRatio;\n            world_scene_height = 1 * scale * 2;\n            x = (i + 0.5) / (scene.width - 1);\n            x = x * 2 - 1;\n            x = x * world_scene_width / 2;\n            y = (-2 * (j + 0.5) / (scene.height - 1) + 1) * world_scene_height / 2;       \n\n            Vector3f dir = Vector3f(x, y, -1); // Don't forget to normalize this direction!\n            framebuffer[m++] = castRay(eye_pos, dir, scene, 0);\n        }\n        UpdateProgress(j / (float)scene.height);\n    }\n\n    // save framebuffer to file\n    FILE* fp = fopen('binary.ppm', 'wb');\n    (void)fprintf(fp, 'P6\\n%d %d\\n255\\n', scene.width, scene.height);\n    for (auto i = 0; i < scene.height * scene.width; ++i) {\n        static unsigned char color[3];\n        color[0] = (char)(255 * clamp(0, 1, framebuffer[i].x));\n        color[1] = (char)(255 * clamp(0, 1, framebuffer[i].y));\n        color[2] = (char)(255 * clamp(0, 1, framebuffer[i].z));\n        fwrite(color, 1, 3, fp);\n    }\n    fclose(fp);    \n}\n```\n\n<img width='1247' height='866' alt='Image' src='https://github.com/user-attachments/assets/2520c58a-5c2b-4027-a353-ebf229cc71c0' />\n\n``` c++\nbool rayTriangleIntersect(const Vector3f& v0, const Vector3f& v1, const Vector3f& v2, const Vector3f& orig,\n                          const Vector3f& dir, float& tnear, float& u, float& v)\n{\n    Vector3f E1 = v1 - v0,\n    E2 = v2 - v0,\n    S = orig - v0,\n    S1 = crossProduct(dir, E2),\n    S2 = crossProduct(S, E1);\n\n    float S1E1 = dotProduct(S1, E1);\n    tnear = dotProduct(S2, E2) / S1E1;\n    u = dotProduct(S1, S) / S1E1;\n    v = dotProduct(S2, dir) / S1E1;\n    if(tnear < 0) return false;\n    if((1 - u - v) > 0 && u > 0 && v > 0) return true;\n    return false;\n}\n```\u3002", "top": 0, "createdAt": 1769182353, "style": "", "script": "", "head": "", "ogImage": "https://github.githubassets.com/favicons/favicon.svg", "createdDate": "2026-01-23", "dateLabelColor": "#1f883d"}, "P9": {"htmlDir": "docs/post/GAMES101 hw6.html", "labels": ["Games101"], "postTitle": "GAMES101 hw6", "postUrl": "post/GAMES101%20hw6.html", "postSourceUrl": "https://github.com/SDJJin1/SDJJin1.github.io/issues/9", "commentNum": 0, "wordCount": 3665, "description": "```  render c++\nvoid Renderer::Render(const Scene& scene)\n{\n    std::vector<Vector3f> framebuffer(scene.width * scene.height);\n\n    float scale = tan(deg2rad(scene.fov * 0.5));\n    float imageAspectRatio = scene.width / (float)scene.height;\n    Vector3f eye_pos(-1, 5, 10);\n    int m = 0;\n    for (uint32_t j = 0; j < scene.height; ++j) {\n        for (uint32_t i = 0; i < scene.width; ++i) {\n            // generate primary ray direction\n            float x = (2 * (i + 0.5) / (float)scene.width - 1) *\n                      imageAspectRatio * scale;\n            float y = (1 - 2 * (j + 0.5) / (float)scene.height) * scale;\n            \n            Vector3f dir = Vector3f(x, y, -1);\n            dir = normalize(dir);\n            framebuffer[m++] = scene.castRay(Ray(eye_pos, dir), 0);\n        }\n        UpdateProgress(j / (float)scene.height);\n    }\n    UpdateProgress(1.f);\n\n    // save framebuffer to file\n    FILE* fp = fopen('binary.ppm', 'wb');\n    (void)fprintf(fp, 'P6\\n%d %d\\n255\\n', scene.width, scene.height);\n    for (auto i = 0; i < scene.height * scene.width; ++i) {\n        static unsigned char color[3];\n        color[0] = (unsigned char)(255 * clamp(0, 1, framebuffer[i].x));\n        color[1] = (unsigned char)(255 * clamp(0, 1, framebuffer[i].y));\n        color[2] = (unsigned char)(255 * clamp(0, 1, framebuffer[i].z));\n        fwrite(color, 1, 3, fp);\n    }\n    fclose(fp);    \n}\n```\n\n``` c++\ninline Intersection Triangle::getIntersection(Ray ray)\n{\n    Intersection inter;\n\n    if (dotProduct(ray.direction, normal) > 0)\n        return inter;\n    double u, v, t_tmp = 0;\n    Vector3f pvec = crossProduct(ray.direction, e2);\n    double det = dotProduct(e1, pvec);\n    if (fabs(det) < EPSILON)\n        return inter;\n\n    double det_inv = 1. / det;\n    Vector3f tvec = ray.origin - v0;\n    u = dotProduct(tvec, pvec) * det_inv;\n    if (u < 0 || u > 1)\n        return inter;\n    Vector3f qvec = crossProduct(tvec, e1);\n    v = dotProduct(ray.direction, qvec) * det_inv;\n    if (v < 0 || u + v > 1)\n        return inter;\n    t_tmp = dotProduct(e2, qvec) * det_inv;\n\n    inter.happened = true;\n    inter.coords = ray(t_tmp);\n    inter.normal = normal;\n    inter.distance = t_tmp;\n    inter.obj = this;\n    inter.m = m;\n\n    return inter;\n}\n``` \n\n``` c++\ninline bool Bounds3::IntersectP(const Ray& ray, const Vector3f& invDir,\n                                const std::array<int, 3>& dirIsNeg) const\n{\n    Vector3f t_min = (pMin - ray.origin) * invDir;\n    Vector3f t_max = (pMax - ray.origin) * invDir;\n\n    float enter_x = dirIsNeg[0] ? t_min.x : t_max.x;\n    float enter_y = dirIsNeg[1] ? t_min.y : t_max.y;\n    float enter_z = dirIsNeg[2] ? t_min.z : t_max.z;\n    float exit_x = dirIsNeg[0] ? t_max.x : t_min.x;\n    float exit_y = dirIsNeg[1] ? t_max.y : t_min.y;\n    float exit_z = dirIsNeg[2] ? t_max.z : t_min.z;\n    \n    float t_enter = fmax(enter_x, fmax(enter_y, enter_z));\n    float t_exit = fmin(exit_x, fmin(exit_y, exit_z));\n\n    return t_enter < t_exit && t_exit >= 0;\n}\n```\n\n\n``` c++\nIntersection BVHAccel::getIntersection(BVHBuildNode* node, const Ray& ray) const\n{\n    Vector3f invDir = ray.direction_inv;\n    Vector3f rayDir = ray.direction;\n    std::array<int, 3> dirIsNeg = {\n        rayDir.x > 0 ? 1 : 0,\n        rayDir.y > 0 ? 1 : 0,\n        rayDir.z > 0 ? 1 : 0\n    };\n\n    if(!node->bounds.IntersectP(ray, invDir, dirIsNeg))\n    {\n        return {};\n    }\n\n    if(node->object)\n    {\n        return node->object->getIntersection(ray);\n    }\n\n    Intersection hit1 = getIntersection(node->left, ray);\n    Intersection hit2 = getIntersection(node->right, ray);\n    \n    return hit1.distance < hit2.distance ? hit1 : hit2;\n}\n```\u3002", "top": 0, "createdAt": 1769260468, "style": "", "script": "", "head": "", "ogImage": "https://github.githubassets.com/favicons/favicon.svg", "createdDate": "2026-01-24", "dateLabelColor": "#1f883d"}}, "singeListJson": {}, "labelColorDict": {"bug": "#d73a4a", "documentation": "#0075ca", "duplicate": "#cfd3d7", "enhancement": "#a2eeef", "Games101": "#df3966", "good first issue": "#7057ff", "help wanted": "#008672", "invalid": "#e4e669", "question": "#d876e3", "wontfix": "#ffffff"}, "displayTitle": "Blog Title", "faviconUrl": "https://github.githubassets.com/favicons/favicon.svg", "ogImage": "https://github.githubassets.com/favicons/favicon.svg", "primerCSS": "<link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />", "homeUrl": "https://SDJJin1.github.io", "prevUrl": "disabled", "nextUrl": "disabled"}