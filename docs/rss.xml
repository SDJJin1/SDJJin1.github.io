<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Blog Title</title><link>https://SDJJin1.github.io</link><description>Blog description</description><copyright>Blog Title</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://github.githubassets.com/favicons/favicon.svg</url><title>avatar</title><link>https://SDJJin1.github.io</link></image><lastBuildDate>Thu, 22 Jan 2026 13:26:01 +0000</lastBuildDate><managingEditor>Blog Title</managingEditor><ttl>60</ttl><webMaster>Blog Title</webMaster><item><title>GAMES101 hw2</title><link>https://SDJJin1.github.io/post/GAMES101%20hw2.html</link><description>首先要判断点在三角形内

&lt;img width='762' height='480' alt='Image' src='https://github.com/user-attachments/assets/9396a6dd-1e88-4825-b61a-06609b5e890a' /&gt;

``` c++
static bool sameSide(Vector3f p, Vector3f a, Vector3f b, Vector3f c)
{
    Vector3f ab = b - a;
    Vector3f ac = c - a;
    Vector3f ap = p - a;
    return (ab.cross(ac)).dot(ab.cross(ap)) &gt;= 0;
}


static bool insideTriangle(int x, int y, const Vector3f* _v)
{   
    Vector3f p = {x, y, 1};

    return sameSide(p, _v[0], _v[1], _v[2]) &amp;&amp;
           sameSide(p, _v[1], _v[2], _v[0]) &amp;&amp;
           sameSide(p, _v[2], _v[0], _v[1]);

}
```

&lt;img width='780' height='478' alt='Image' src='https://github.com/user-attachments/assets/902607b6-b3cb-4ef1-9810-aad9c87a159c' /&gt;

``` c++
void rst::rasterizer::rasterize_triangle(const Triangle&amp; t) {
    auto v = t.toVector4();

    int minx = INT_MAX;
    int maxx = INT_MIN;
    int miny = INT_MAX;
    int maxy = INT_MIN;

    for(auto&amp; i : v)
    {
        minx = i.x() &lt; minx ? i.x() : minx;
        miny = i.y() &lt; miny ? i.y() : miny;
        maxx = i.x() &gt; maxx ? i.x() : maxx;
        maxy = i.y() &gt; maxy ? i.y() : maxy;
    }
    
    for(int i = minx; i &lt;= maxx; i++)
    {
        for(int j = miny; j &lt;= maxy; j++)
        {
            float x = i + 0.5f;
            float y = j + 0.5f;

            if(insideTriangle(x, y, t.v))
            {
                auto[alpha, beta, gamma] = computeBarycentric2D(x, y, t.v);
                float w_reciprocal = 1.0/(alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w());
                float z_interpolated = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w();
                z_interpolated *= w_reciprocal;
                
                int index = get_index(i, j);
                if(z_interpolated &lt; depth_buf[index])
                {
                    depth_buf[index] = z_interpolated;
                    set_pixel(Eigen::Vector3f(i, j, z_interpolated), t.getColor());
                }
            }
        }
    }
}
```。</description><guid isPermaLink="true">https://SDJJin1.github.io/post/GAMES101%20hw2.html</guid><pubDate>Thu, 22 Jan 2026 13:25:30 +0000</pubDate></item><item><title>GAMES101 hw1</title><link>https://SDJJin1.github.io/post/GAMES101%20hw1.html</link><description>根据课上讲的求模型矩阵的方法

&lt;img width='999' height='654' alt='Image' src='https://github.com/user-attachments/assets/66c8a127-94f3-4214-9559-352d19a612f4' /&gt;

``` c++
Eigen::Matrix4f get_model_matrix(float rotation_angle)
{
    Eigen::Matrix4f model = Eigen::Matrix4f::Identity();
    float arc1 = rotation_angle / 180.0 * acos(-1);
    model &lt;&lt; std::cos(arc1), -std::sin(arc1), 0, 0,
            std::sin(arc1), std::cos(arc1), 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1;

    return model;
}
```

要求投影矩阵，就要先得到正交矩阵，然后挤压成投影矩阵

&lt;img width='1252' height='819' alt='Image' src='https://github.com/user-attachments/assets/74ec068e-2a5c-485f-9915-67671bb788ea' /&gt;

求正交矩阵的方法

&lt;img width='1132' height='751' alt='Image' src='https://github.com/user-attachments/assets/c9abdbb9-46a1-4245-930e-9a55006aa629' /&gt;

由正交矩阵挤压成投影矩阵

&lt;img width='343' height='146' alt='Image' src='https://github.com/user-attachments/assets/ae19a871-24a7-46db-a9c3-335e8ae47138' /&gt;

再由fov求其他参数

&lt;img width='971' height='548' alt='Image' src='https://github.com/user-attachments/assets/65d17868-4d03-4e7c-b506-da25c6fdf0ba' /&gt;

``` c++
Eigen::Matrix4f get_projection_matrix(float eye_fov, float aspect_ratio,
                                      float zNear, float zFar)
{
    Eigen::Matrix4f projection = Eigen::Matrix4f::Identity();

    float t = std::tan(eye_fov) * std::abs(zNear);
    float b = t * -1;
    float r = aspect_ratio * t;
    float l = r * -1;

    Eigen::Matrix4f ortho;
    ortho &lt;&lt; 2/ (r - l), 0, 0, 0,
            0, 2/ (t - b), 0, 0,
            0, 0, 2/ (zNear - zFar), 0,
            0, 0, 0, 1;

    Eigen::Matrix4f x;
    x &lt;&lt; 1, 0, 0, -((r + l) / 2),
        0, 1, 0, -((t + b) / 2),
        0, 0, 1, -((zNear + zFar)),
        0, 0, 0, 1;
    
    ortho = ortho * x;

    Eigen::Matrix4f persp;
    persp &lt;&lt; zNear, 0, 0, 0,
            0, zNear, 0, 0,
            0, 0, zNear, -1 * zNear * zFar,
            0, 0, 1, 0;

    projection = ortho * persp;

    return projection;
}
```。</description><guid isPermaLink="true">https://SDJJin1.github.io/post/GAMES101%20hw1.html</guid><pubDate>Wed, 21 Jan 2026 13:54:37 +0000</pubDate></item><item><title>GAMES101 hw0</title><link>https://SDJJin1.github.io/post/GAMES101%20hw0.html</link><description>照题目模拟即可
``` c++
#include&lt;cmath&gt;
#include&lt;eigen3/Eigen/Core&gt;
#include&lt;eigen3/Eigen/Dense&gt;
#include&lt;iostream&gt;

int main(){
    float arc1 = 45.0 / 180.0 * acos(-1);
    Eigen::Vector3f ans(2.0, 1.0, 1.0);
    Eigen::Matrix3f Rot;
    Rot &lt;&lt; std::cos(arc1), std::sin(-arc1), 0,
            std::sin(arc1), std::cos(arc1), 0,
            0, 0, 1;
    ans = Rot * ans;
    Eigen::Matrix3f Trans;
    Trans &lt;&lt; 1.0, 0.0, 1.0,
            0.0, 1.0, 2.0,
            0.0, 0.0, 1.0;
    ans = Trans * ans;
    std::cout &lt;&lt; ans &lt;&lt; std::endl;

    return 0;
}
```。</description><guid isPermaLink="true">https://SDJJin1.github.io/post/GAMES101%20hw0.html</guid><pubDate>Wed, 21 Jan 2026 13:15:18 +0000</pubDate></item><item><title>Test</title><link>https://SDJJin1.github.io/post/Test.html</link><description>Hello World。</description><guid isPermaLink="true">https://SDJJin1.github.io/post/Test.html</guid><pubDate>Thu, 04 Dec 2025 15:33:21 +0000</pubDate></item></channel></rss>