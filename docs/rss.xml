<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Blog Title</title><link>https://SDJJin1.github.io</link><description>Blog description</description><copyright>Blog Title</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://github.githubassets.com/favicons/favicon.svg</url><title>avatar</title><link>https://SDJJin1.github.io</link></image><lastBuildDate>Fri, 20 Feb 2026 16:43:06 +0000</lastBuildDate><managingEditor>Blog Title</managingEditor><ttl>60</ttl><webMaster>Blog Title</webMaster><item><title>Games103 hw2</title><link>https://SDJJin1.github.io/post/Games103%20hw2.html</link><description>``` c++
void Get_Gradient(Vector3[] X, Vector3[] X_hat, float t, Vector3[] G)
	{
		for (int i = 0; i &lt; G.Length; i++)
		{
			G[i] = (mass / (t * t)) * (X[i] - X_hat[i]) - mass * new Vector3(0, -9.8f, 0);
		}

		for (int e = 0; e &lt; E.Length / 2; e++)
		{
			int i = E[e * 2 + 0];
			int j = E[e * 2 + 1];
			
			Vector3 f = spring_k * (1-L[e] / (X[i] - X[j]).magnitude) *(X[i] - X[j]);
			G[i] += f;
			G[j] -= f;
		}
	}
```

``` c++
void Update () 
	{
		Mesh mesh = GetComponent&lt;MeshFilter&gt; ().mesh;
		Vector3[] X 		= mesh.vertices;
		Vector3[] last_X 	= new Vector3[X.Length];
		Vector3[] X_hat 	= new Vector3[X.Length];
		Vector3[] G 		= new Vector3[X.Length];

		//Initial Setup.
		for (int i = 0; i &lt; X.Length; i++)
		{
			V[i] *= damping;
			X[i] = X_hat[i]= X[i] + t * V[i];
		}

		float omega = 1.0f;
		for(int k=0; k&lt;32; k++)
		{
			if (k == 0) omega = 1.0f;
			else if (k == 1) omega = 2.0f / (2.0f - rho * rho);
			else omega = 4.0f / (4.0f - rho * rho * omega);
			
			Get_Gradient(X, X_hat, t, G);
			
			//Update X by gradient.
			for (int i = 0; i &lt; X.Length; i++)
			{
				if(i == 0 || i == 20) continue;
				
				Vector3 new_x = omega * (X[i] - 1/ (mass / (t * t) + spring_k*4)*G[i])
					+ (1-omega)*last_X[i];
				last_X[i] = X[i];
				X[i] = new_x;
			}
		}

		for (int i = 0; i &lt; X.Length; i++)
		{
			V[i] += (X[i] - X_hat[i]) / t;
		}
		
		mesh.vertices = X;

		Collision_Handling ();
		mesh.RecalculateNormals ();
	}
```。</description><guid isPermaLink="true">https://SDJJin1.github.io/post/Games103%20hw2.html</guid><pubDate>Fri, 20 Feb 2026 10:12:16 +0000</pubDate></item><item><title>Games103 hw1</title><link>https://SDJJin1.github.io/post/Games103%20hw1.html</link><description>impulse方法
``` c++
void Collision_Impulse(Vector3 P, Vector3 N)
	{
		Mesh mesh = GetComponent&lt;MeshFilter&gt;().mesh;
		Vector3[] vertices = mesh.vertices;
		
		Matrix4x4 R = Matrix4x4.Rotate(this.transform.rotation);
		Vector3 T = transform.position;
		
		Vector3 sum = Vector3.zero;
		int collisionNum = 0;

		for (int i = 0; i &lt; vertices.Length; i++)
		{
			Vector3 r_i = vertices[i];
			Vector3 Rri = R.MultiplyVector(r_i);
			Vector3 x_i = T + Rri;
			float d = Vector3.Dot(x_i - P, N);
			if (d &lt; 0.0f) // collision occur
			{
				Vector3 v_i = v + Vector3.Cross(w, Rri);
				float v_N_size = Vector3.Dot(v_i, N);
				// check velocity
				if (v_N_size &lt; 0.0f)
				{
					sum += r_i;
					collisionNum++;
				}
			}
		}
		
		if (collisionNum == 0) return;
		Matrix4x4 I_rot = R * I_ref * R.transpose;
		Matrix4x4 I_inverse = I_rot.inverse;      
		Vector3 r_collision = sum / (float)collisionNum;                // virtual collision point（local coordination）
		Vector3 Rr_collision = R.MultiplyVector(r_collision);
		//Vector3 x_collision = T + Rr_collision;							 // virtual collision point（global coordination）
		Vector3 v_collision = v + Vector3.Cross(w, Rr_collision);
        
		// Compute the wanted v_N
		Vector3 v_N = Vector3.Dot(v_collision, N) * N;
		Vector3 v_T = v_collision - v_N;
		Vector3 v_N_new = -1.0f * restitution * v_N;
		float a = Math.Max(1.0f - friction * (1.0f + restitution) * v_N.magnitude / v_T.magnitude, 0.0f);
		Vector3 v_T_new = a * v_T;
		Vector3 v_new = v_N_new + v_T_new;
        
		// Compute the impulse J
		Matrix4x4 Rri_star = Get_Cross_Matrix(Rr_collision);
		Matrix4x4 K = Matrix_subtraction(Matrix_miltiply_float(Matrix4x4.identity, 1.0f / mass),
			Rri_star * I_inverse * Rri_star);
		Vector3 J = K.inverse.MultiplyVector(v_new - v_collision);
        
		// Update v and w with impulse J
		v = v + 1.0f / mass * J;
		w = w + I_inverse.MultiplyVector(Vector3.Cross(Rr_collision, J));
	}
```

。</description><guid isPermaLink="true">https://SDJJin1.github.io/post/Games103%20hw1.html</guid><pubDate>Fri, 20 Feb 2026 10:05:27 +0000</pubDate></item><item><title>GAMES101 hw7</title><link>https://SDJJin1.github.io/post/GAMES101%20hw7.html</link><description>``` c++
Vector3f Scene::castRay(const Ray &amp;ray, int depth) const
{
    Vector3f hitColor = this-&gt;backgroundColor;
    Intersection shade_point_inter = Scene::intersect(ray);
    if (shade_point_inter.happened)
    {

        Vector3f p = shade_point_inter.coords;
        Vector3f wo = ray.direction;
        Vector3f N = shade_point_inter.normal;
        Vector3f L_dir(0), L_indir(0);

       //sampleLight(inter,pdf_light)
        Intersection light_point_inter;
        float pdf_light;
        sampleLight(light_point_inter, pdf_light);
        //Get x,ws,NN,emit from inter
        Vector3f x = light_point_inter.coords;
        Vector3f ws = normalize(x-p);
        Vector3f NN = light_point_inter.normal;
        Vector3f emit = light_point_inter.emit;
        float distance_pTox = (x - p).norm();
        //Shoot a ray from p to x
        Vector3f p_deviation = (dotProduct(ray.direction, N) &lt; 0) ?
                p + N * EPSILON :
                p - N * EPSILON ;

        Ray ray_pTox(p_deviation, ws);
        //If the ray is not blocked in the middleff
        Intersection blocked_point_inter = Scene::intersect(ray_pTox);
        if (abs(distance_pTox - blocked_point_inter.distance &lt; 0.01 ))
        {
            L_dir = emit * shade_point_inter.m-&gt;eval(wo, ws, N) * dotProduct(ws, N) * dotProduct(-ws, NN) / (distance_pTox * distance_pTox * pdf_light);
        }
        //Test Russian Roulette with probability RussianRouolette
        float ksi = get_random_float();
        if (ksi &lt; RussianRoulette)
        {
            //wi=sample(wo,N)
            Vector3f wi = normalize(shade_point_inter.m-&gt;sample(wo, N));
            //Trace a ray r(p,wi)
            Ray ray_pTowi(p_deviation, wi);
            //If ray r hit a non-emitting object at q
            Intersection bounce_point_inter = Scene::intersect(ray_pTowi);
            if (bounce_point_inter.happened &amp;&amp; !bounce_point_inter.m-&gt;hasEmission())
            {
                float pdf = shade_point_inter.m-&gt;pdf(wo, wi, N);
                if(pdf&gt; EPSILON)
                    L_indir = castRay(ray_pTowi, depth + 1) * shade_point_inter.m-&gt;eval(wo, wi, N) * dotProduct(wi, N) / (pdf *RussianRoulette);
            }
        }
        hitColor = shade_point_inter.m-&gt;getEmission() + L_dir + L_indir;
    }
    return hitColor;
}
```
得到结果

&lt;img width='493' height='486' alt='Image' src='https://github.com/user-attachments/assets/674c57ad-224b-446d-8bc8-20b4d97f7983' /&gt;。</description><guid isPermaLink="true">https://SDJJin1.github.io/post/GAMES101%20hw7.html</guid><pubDate>Sat, 24 Jan 2026 13:20:46 +0000</pubDate></item><item><title>GAMES101 hw6</title><link>https://SDJJin1.github.io/post/GAMES101%20hw6.html</link><description>```  render c++
void Renderer::Render(const Scene&amp; scene)
{
    std::vector&lt;Vector3f&gt; framebuffer(scene.width * scene.height);

    float scale = tan(deg2rad(scene.fov * 0.5));
    float imageAspectRatio = scene.width / (float)scene.height;
    Vector3f eye_pos(-1, 5, 10);
    int m = 0;
    for (uint32_t j = 0; j &lt; scene.height; ++j) {
        for (uint32_t i = 0; i &lt; scene.width; ++i) {
            // generate primary ray direction
            float x = (2 * (i + 0.5) / (float)scene.width - 1) *
                      imageAspectRatio * scale;
            float y = (1 - 2 * (j + 0.5) / (float)scene.height) * scale;
            
            Vector3f dir = Vector3f(x, y, -1);
            dir = normalize(dir);
            framebuffer[m++] = scene.castRay(Ray(eye_pos, dir), 0);
        }
        UpdateProgress(j / (float)scene.height);
    }
    UpdateProgress(1.f);

    // save framebuffer to file
    FILE* fp = fopen('binary.ppm', 'wb');
    (void)fprintf(fp, 'P6\n%d %d\n255\n', scene.width, scene.height);
    for (auto i = 0; i &lt; scene.height * scene.width; ++i) {
        static unsigned char color[3];
        color[0] = (unsigned char)(255 * clamp(0, 1, framebuffer[i].x));
        color[1] = (unsigned char)(255 * clamp(0, 1, framebuffer[i].y));
        color[2] = (unsigned char)(255 * clamp(0, 1, framebuffer[i].z));
        fwrite(color, 1, 3, fp);
    }
    fclose(fp);    
}
```

``` c++
inline Intersection Triangle::getIntersection(Ray ray)
{
    Intersection inter;

    if (dotProduct(ray.direction, normal) &gt; 0)
        return inter;
    double u, v, t_tmp = 0;
    Vector3f pvec = crossProduct(ray.direction, e2);
    double det = dotProduct(e1, pvec);
    if (fabs(det) &lt; EPSILON)
        return inter;

    double det_inv = 1. / det;
    Vector3f tvec = ray.origin - v0;
    u = dotProduct(tvec, pvec) * det_inv;
    if (u &lt; 0 || u &gt; 1)
        return inter;
    Vector3f qvec = crossProduct(tvec, e1);
    v = dotProduct(ray.direction, qvec) * det_inv;
    if (v &lt; 0 || u + v &gt; 1)
        return inter;
    t_tmp = dotProduct(e2, qvec) * det_inv;

    inter.happened = true;
    inter.coords = ray(t_tmp);
    inter.normal = normal;
    inter.distance = t_tmp;
    inter.obj = this;
    inter.m = m;

    return inter;
}
``` 

``` c++
inline bool Bounds3::IntersectP(const Ray&amp; ray, const Vector3f&amp; invDir,
                                const std::array&lt;int, 3&gt;&amp; dirIsNeg) const
{
    Vector3f t_min = (pMin - ray.origin) * invDir;
    Vector3f t_max = (pMax - ray.origin) * invDir;

    float enter_x = dirIsNeg[0] ? t_min.x : t_max.x;
    float enter_y = dirIsNeg[1] ? t_min.y : t_max.y;
    float enter_z = dirIsNeg[2] ? t_min.z : t_max.z;
    float exit_x = dirIsNeg[0] ? t_max.x : t_min.x;
    float exit_y = dirIsNeg[1] ? t_max.y : t_min.y;
    float exit_z = dirIsNeg[2] ? t_max.z : t_min.z;
    
    float t_enter = fmax(enter_x, fmax(enter_y, enter_z));
    float t_exit = fmin(exit_x, fmin(exit_y, exit_z));

    return t_enter &lt; t_exit &amp;&amp; t_exit &gt;= 0;
}
```


``` c++
Intersection BVHAccel::getIntersection(BVHBuildNode* node, const Ray&amp; ray) const
{
    Vector3f invDir = ray.direction_inv;
    Vector3f rayDir = ray.direction;
    std::array&lt;int, 3&gt; dirIsNeg = {
        rayDir.x &gt; 0 ? 1 : 0,
        rayDir.y &gt; 0 ? 1 : 0,
        rayDir.z &gt; 0 ? 1 : 0
    };

    if(!node-&gt;bounds.IntersectP(ray, invDir, dirIsNeg))
    {
        return {};
    }

    if(node-&gt;object)
    {
        return node-&gt;object-&gt;getIntersection(ray);
    }

    Intersection hit1 = getIntersection(node-&gt;left, ray);
    Intersection hit2 = getIntersection(node-&gt;right, ray);
    
    return hit1.distance &lt; hit2.distance ? hit1 : hit2;
}
```。</description><guid isPermaLink="true">https://SDJJin1.github.io/post/GAMES101%20hw6.html</guid><pubDate>Sat, 24 Jan 2026 13:14:28 +0000</pubDate></item><item><title>GAMES101 hw5</title><link>https://SDJJin1.github.io/post/GAMES101%20hw5.html</link><description>``` c++
void Renderer::Render(const Scene&amp; scene)
{
    std::vector&lt;Vector3f&gt; framebuffer(scene.width * scene.height);

    float scale = std::tan(deg2rad(scene.fov * 0.5f));
    float imageAspectRatio = scene.width / (float)scene.height;

    // Use this variable as the eye position to start your rays.
    Vector3f eye_pos(0);
    int m = 0;
    for (int j = 0; j &lt; scene.height; ++j)
    {
        for (int i = 0; i &lt; scene.width; ++i)
        {
            // generate primary ray direction
            float x, world_scene_width;
            float y, world_scene_height;
            world_scene_width = 1 * scale * 2 * imageAspectRatio;
            world_scene_height = 1 * scale * 2;
            x = (i + 0.5) / (scene.width - 1);
            x = x * 2 - 1;
            x = x * world_scene_width / 2;
            y = (-2 * (j + 0.5) / (scene.height - 1) + 1) * world_scene_height / 2;       

            Vector3f dir = Vector3f(x, y, -1); // Don't forget to normalize this direction!
            framebuffer[m++] = castRay(eye_pos, dir, scene, 0);
        }
        UpdateProgress(j / (float)scene.height);
    }

    // save framebuffer to file
    FILE* fp = fopen('binary.ppm', 'wb');
    (void)fprintf(fp, 'P6\n%d %d\n255\n', scene.width, scene.height);
    for (auto i = 0; i &lt; scene.height * scene.width; ++i) {
        static unsigned char color[3];
        color[0] = (char)(255 * clamp(0, 1, framebuffer[i].x));
        color[1] = (char)(255 * clamp(0, 1, framebuffer[i].y));
        color[2] = (char)(255 * clamp(0, 1, framebuffer[i].z));
        fwrite(color, 1, 3, fp);
    }
    fclose(fp);    
}
```

&lt;img width='1247' height='866' alt='Image' src='https://github.com/user-attachments/assets/2520c58a-5c2b-4027-a353-ebf229cc71c0' /&gt;

``` c++
bool rayTriangleIntersect(const Vector3f&amp; v0, const Vector3f&amp; v1, const Vector3f&amp; v2, const Vector3f&amp; orig,
                          const Vector3f&amp; dir, float&amp; tnear, float&amp; u, float&amp; v)
{
    Vector3f E1 = v1 - v0,
    E2 = v2 - v0,
    S = orig - v0,
    S1 = crossProduct(dir, E2),
    S2 = crossProduct(S, E1);

    float S1E1 = dotProduct(S1, E1);
    tnear = dotProduct(S2, E2) / S1E1;
    u = dotProduct(S1, S) / S1E1;
    v = dotProduct(S2, dir) / S1E1;
    if(tnear &lt; 0) return false;
    if((1 - u - v) &gt; 0 &amp;&amp; u &gt; 0 &amp;&amp; v &gt; 0) return true;
    return false;
}
```。</description><guid isPermaLink="true">https://SDJJin1.github.io/post/GAMES101%20hw5.html</guid><pubDate>Fri, 23 Jan 2026 15:32:33 +0000</pubDate></item><item><title>GAMES101 hw4</title><link>https://SDJJin1.github.io/post/GAMES101%20hw4.html</link><description>根据课上讲的

&lt;img width='990' height='614' alt='Image' src='https://github.com/user-attachments/assets/86c183bf-26e9-449a-83d8-eab3299f9a12' /&gt;

``` c++
cv::Point2f recursive_bezier(const std::vector&lt;cv::Point2f&gt; &amp;control_points, float t) 
{
    if (control_points.size() == 2)
    {
        return (1 - t) * control_points[0] + t * control_points[1];
    }

    std::vector&lt;cv::Point2f&gt; new_control_points;

    for (int i = 0; i &lt; control_points.size() - 1; i++)
    {
        new_control_points.push_back((1 - t) * control_points[i] + t * control_points[i+1]);
    }
    
    return recursive_bezier(new_control_points, t);

}

void bezier(const std::vector&lt;cv::Point2f&gt; &amp;control_points, cv::Mat &amp;window) 
{
    for (float t = 0; t &lt;= 1; t += 0.001)
    {
        auto point = recursive_bezier(control_points, t);
        window.at&lt;cv::Vec3b&gt;(point.y, point.x)[1] = 255;
    }
}
```

&lt;img width='700' height='700' alt='Image' src='https://github.com/user-attachments/assets/08601d97-9ad4-4bda-9cf6-49450f29be63' /&gt;。</description><guid isPermaLink="true">https://SDJJin1.github.io/post/GAMES101%20hw4.html</guid><pubDate>Fri, 23 Jan 2026 15:21:26 +0000</pubDate></item><item><title>GAMES101 hw3</title><link>https://SDJJin1.github.io/post/GAMES101%20hw3.html</link><description>hw3和hw2在rasterize_triangle函数上的区别是需要自己计算插值

``` c++
void rst::rasterizer::rasterize_triangle(const Triangle&amp; t, const std::array&lt;Eigen::Vector3f, 3&gt;&amp; view_pos) 
{
    auto v = t.toVector4();

    int minx = INT_MAX;
    int maxx = INT_MIN;
    int miny = INT_MAX;
    int maxy = INT_MIN;

    for(auto&amp; i : v)
    {
        minx = i.x() &lt; minx ? i.x() : minx;
        miny = i.y() &lt; miny ? i.y() : miny;
        maxx = i.x() &gt; maxx ? i.x() : maxx;
        maxy = i.y() &gt; maxy ? i.y() : maxy;
    }

    for(int i = minx; i &lt;= maxx; i++)
    {
        for(int j = miny; j &lt;= maxy; j++)
        {
            float x = i + 0.5f;
            float y = j + 0.5f;

            if(insideTriangle(x, y, t.v))
            {
                auto[alpha, beta, gamma] = computeBarycentric2D(x, y, t.v);
                float Z = 1.0 / (alpha / v[0].w() + beta / v[1].w() + gamma/v[2].w());
    			float zp = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w();
    		    zp *= Z;
                
                int index = get_index(i, j);
                if(zp &lt; depth_buf[index])
                {
                    auto interpolated_color = interpolate(alpha, beta, gamma, t.color[0], t.color[1], t.color[2], 1);
                    auto interpolated_normal = interpolate(alpha, beta, gamma, t.normal[0], t.normal[1], t.normal[2], 1).normalized();
                    auto interpolated_texcoords = interpolate(alpha, beta, gamma, t.tex_coords[0], t.tex_coords[1], t.tex_coords[2], 1);
    			    auto interpolated_shadingcoords = interpolate(alpha, beta, gamma, view_pos[0], view_pos[1], view_pos[2], 1);
                    
                    fragment_shader_payload payload(interpolated_color, interpolated_normal.normalized(), interpolated_texcoords, texture ? &amp;*texture : nullptr);
                    payload.view_pos = interpolated_shadingcoords;
			  depth_buf[index] = zp;
                    auto pixel_color = fragment_shader(payload);

                    set_pixel(Eigen::Vector2i(i, j), pixel_color);
                }
            }
        }
    }
}
```

完成后就可以得到

&lt;img width='700' height='700' alt='Image' src='https://github.com/user-attachments/assets/708b1b64-2b6d-4cc7-995f-efd79ce57af9' /&gt;

Blinn-Phong模型的公式

&lt;img width='1003' height='633' alt='Image' src='https://github.com/user-attachments/assets/a78e832d-0622-47b5-a728-3a2e3745d473' /&gt;

``` c++
Eigen::Vector3f phong_fragment_shader(const fragment_shader_payload&amp; payload)
{
    Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005);
    Eigen::Vector3f kd = payload.color;
    Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937);

    auto l1 = light{{20, 20, 20}, {500, 500, 500}};
    auto l2 = light{{-20, 20, 0}, {500, 500, 500}};

    std::vector&lt;light&gt; lights = {l1, l2};
    Eigen::Vector3f amb_light_intensity{10, 10, 10};
    Eigen::Vector3f eye_pos{0, 0, 10};

    float p = 150;

    Eigen::Vector3f color = payload.color;
    Eigen::Vector3f point = payload.view_pos;
    Eigen::Vector3f normal = payload.normal;

    Eigen::Vector3f result_color = {0, 0, 0};
    for (auto&amp; light : lights)
    {
        Eigen::Vector3f light_direction = (light.position - point).normalized();
        Eigen::Vector3f view_direction = (eye_pos - point).normalized();
        Eigen::Vector3f half_vector = (light_direction + view_direction).normalized();

        float reflection_intensity = std::max(0.0f, half_vector.dot(normal));

        float light_intensity_attenuation = (light.position - point).dot(light.position - point);

        Eigen::Vector3f diffuse_reflection = kd.cwiseProduct(light.intensity / light_intensity_attenuation);
        diffuse_reflection *= reflection_intensity;

        Eigen::Vector3f high_lights = ks.cwiseProduct(light.intensity / light_intensity_attenuation);
        high_lights *= std::pow(reflection_intensity, p);

        result_color += (diffuse_reflection + high_lights);
        
    }

    Eigen::Vector3f ambient_light_reflection = ka.cwiseProduct(amb_light_intensity);

    result_color += ambient_light_reflection;

    return result_color * 255.f;
}
```
就可以得到

&lt;img width='700' height='700' alt='Image' src='https://github.com/user-attachments/assets/ce183f1d-4fcf-4a16-9dae-bff3e108d667' /&gt;

按题目的要求，将纹理颜色视为公式中的kd
``` c++
Eigen::Vector3f texture_fragment_shader(const fragment_shader_payload&amp; payload)
{
    Eigen::Vector3f return_color = {0, 0, 0};
    if (payload.texture)
    {
     return_color = payload.texture-&gt;getColor(payload.tex_coords.x(), payload.tex_coords.y());

    }
    Eigen::Vector3f texture_color;
    texture_color &lt;&lt; return_color.x(), return_color.y(), return_color.z();

    Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005);
    Eigen::Vector3f kd = texture_color / 255.f;
    Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937);

    auto l1 = light{{20, 20, 20}, {500, 500, 500}};
    auto l2 = light{{-20, 20, 0}, {500, 500, 500}};

    std::vector&lt;light&gt; lights = {l1, l2};
    Eigen::Vector3f amb_light_intensity{10, 10, 10};
    Eigen::Vector3f eye_pos{0, 0, 10};

    float p = 150;

    Eigen::Vector3f color = texture_color;
    Eigen::Vector3f point = payload.view_pos;
    Eigen::Vector3f normal = payload.normal;

    Eigen::Vector3f result_color = {0, 0, 0};

    for (auto&amp; light : lights)
    {
        Eigen::Vector3f light_direction = (light.position - point).normalized();
        Eigen::Vector3f view_direction = (eye_pos - point).normalized();
        Eigen::Vector3f half_vector = (light_direction + view_direction).normalized();

        float reflection_intensity = std::max(0.0f, half_vector.dot(normal));

        float light_intensity_attenuation = (light.position - point).dot(light.position - point);

        Eigen::Vector3f diffuse_reflection = kd.cwiseProduct(light.intensity / light_intensity_attenuation);
        diffuse_reflection *= reflection_intensity;

        Eigen::Vector3f high_lights = ks.cwiseProduct(light.intensity / light_intensity_attenuation);
        high_lights *= std::pow(reflection_intensity, p);

        result_color += (diffuse_reflection + high_lights);
    }
        Eigen::Vector3f ambient_light_reflection = ka.cwiseProduct(amb_light_intensity);

        result_color += ambient_light_reflection;

    return result_color * 255.f;
}
```

&lt;img width='700' height='700' alt='Image' src='https://github.com/user-attachments/assets/b006f374-e3bd-4c85-84d8-f5c362f1c4e9' /&gt;

bump
``` c++
Eigen::Vector3f bump_fragment_shader(const fragment_shader_payload&amp; payload)
{
    
    Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005);
    Eigen::Vector3f kd = payload.color;
    Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937);

    auto l1 = light{{20, 20, 20}, {500, 500, 500}};
    auto l2 = light{{-20, 20, 0}, {500, 500, 500}};

    std::vector&lt;light&gt; lights = {l1, l2};
    Eigen::Vector3f amb_light_intensity{10, 10, 10};
    Eigen::Vector3f eye_pos{0, 0, 10};

    float p = 150;

    Eigen::Vector3f color = payload.color; 
    Eigen::Vector3f point = payload.view_pos;
    Eigen::Vector3f normal = payload.normal;


    float kh = 0.2, kn = 0.1;

 
    float x = normal.x();
    float y = normal.y();
    float z = normal.z();
    Eigen::Vector3f t = {-x*y/sqrt(x*x+z*z),sqrt(x*x+z*z),-z*y/sqrt(x*x+z*z)};
    Eigen::Vector3f b = normal.cross(t);
    Eigen::Matrix3f TBN;
    TBN &lt;&lt; t.x(), b.x(), normal.x(), t.y(), b.y(), normal.y(), t.z(), b.z(), normal.z();
    float u = payload.tex_coords.x();
    float v = payload.tex_coords.y();
    float w = payload.texture-&gt;width;
    float h = payload.texture-&gt;height;
    float dU = kh * kn *(payload.texture-&gt;getColor(u + 1.0 / w, v).norm() - payload.texture-&gt;getColor(u, v).norm());
    float dV = kh * kn *(payload.texture-&gt;getColor(u, v + 1.0 / h).norm() - payload.texture-&gt;getColor(u, v).norm());

    Eigen::Vector3f ln = {-dU, -dV, 1};
    normal = (TBN * ln).normalized();

    Eigen::Vector3f result_color = {0, 0, 0};
    result_color = normal;

    return result_color * 255.f;
}
```
&lt;img width='700' height='700' alt='Image' src='https://github.com/user-attachments/assets/cc0e7179-98de-41f4-bd74-f0cc7bac9d1c' /&gt;

displacement
``` c++
Eigen::Vector3f displacement_fragment_shader(const fragment_shader_payload&amp; payload)
{
    
    Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005);
    Eigen::Vector3f kd = payload.color;
    Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937);

    auto l1 = light{{20, 20, 20}, {500, 500, 500}};
    auto l2 = light{{-20, 20, 0}, {500, 500, 500}};

    std::vector&lt;light&gt; lights = {l1, l2};
    Eigen::Vector3f amb_light_intensity{10, 10, 10};
    Eigen::Vector3f eye_pos{0, 0, 10};

    float p = 150;

    Eigen::Vector3f color = payload.color; 
    Eigen::Vector3f point = payload.view_pos;
    Eigen::Vector3f normal = payload.normal;

    float kh = 0.2, kn = 0.1;
    
    float x = normal.x();
    float y = normal.y();
    float z = normal.z();
    Eigen::Vector3f t = {-x*y/sqrt(x*x+z*z),sqrt(x*x+z*z),-z*y/sqrt(x*x+z*z)};
    Eigen::Vector3f b = normal.cross(t);
    Eigen::Matrix3f TBN;
    TBN &lt;&lt; t.x(), b.x(), normal.x(), t.y(), b.y(), normal.y(), t.z(), b.z(), normal.z();
    float u = payload.tex_coords.x();
    float v = payload.tex_coords.y();
    float w = payload.texture-&gt;width;
    float h = payload.texture-&gt;height;
    float dU = kh * kn *(payload.texture-&gt;getColor(u + 1.0 / w, v).norm() - payload.texture-&gt;getColor(u, v).norm());
    float dV = kh * kn *(payload.texture-&gt;getColor(u, v + 1.0 / h).norm() - payload.texture-&gt;getColor(u, v).norm());

    Eigen::Vector3f ln = {-dU, -dV, 1};
    normal = (TBN * ln).normalized();


    Eigen::Vector3f result_color = {0, 0, 0};

    for (auto&amp; light : lights)
    {
        Eigen::Vector3f light_direction = (light.position - point).normalized();
        Eigen::Vector3f view_direction = (eye_pos - point).normalized();
        Eigen::Vector3f half_vector = (light_direction + view_direction).normalized();

        float reflection_intensity = std::max(0.0f, half_vector.dot(normal));

        float light_intensity_attenuation = (light.position - point).dot(light.position - point);

        Eigen::Vector3f diffuse_reflection = kd.cwiseProduct(light.intensity / light_intensity_attenuation);
        diffuse_reflection *= reflection_intensity;

        Eigen::Vector3f high_lights = ks.cwiseProduct(light.intensity / light_intensity_attenuation);
        high_lights *= std::pow(reflection_intensity, p);

        result_color += (diffuse_reflection + high_lights);


    }

    Eigen::Vector3f ambient_light_reflection = ka.cwiseProduct(amb_light_intensity);

    result_color += ambient_light_reflection;
    return result_color * 255.f;
}
```

&lt;img width='700' height='700' alt='Image' src='https://github.com/user-attachments/assets/88b7701e-5797-4bb2-aa3f-ee47fd00b165' /&gt;。</description><guid isPermaLink="true">https://SDJJin1.github.io/post/GAMES101%20hw3.html</guid><pubDate>Fri, 23 Jan 2026 14:58:54 +0000</pubDate></item><item><title>GAMES101 hw2</title><link>https://SDJJin1.github.io/post/GAMES101%20hw2.html</link><description>首先要判断点在三角形内

&lt;img width='762' height='480' alt='Image' src='https://github.com/user-attachments/assets/9396a6dd-1e88-4825-b61a-06609b5e890a' /&gt;

``` c++
static bool sameSide(Vector3f p, Vector3f a, Vector3f b, Vector3f c)
{
    Vector3f ab = b - a;
    Vector3f ac = c - a;
    Vector3f ap = p - a;
    return (ab.cross(ac)).dot(ab.cross(ap)) &gt;= 0;
}


static bool insideTriangle(int x, int y, const Vector3f* _v)
{   
    Vector3f p = {x, y, 1};

    return sameSide(p, _v[0], _v[1], _v[2]) &amp;&amp;
           sameSide(p, _v[1], _v[2], _v[0]) &amp;&amp;
           sameSide(p, _v[2], _v[0], _v[1]);

}
```

&lt;img width='780' height='478' alt='Image' src='https://github.com/user-attachments/assets/902607b6-b3cb-4ef1-9810-aad9c87a159c' /&gt;

``` c++
void rst::rasterizer::rasterize_triangle(const Triangle&amp; t) {
    auto v = t.toVector4();

    int minx = INT_MAX;
    int maxx = INT_MIN;
    int miny = INT_MAX;
    int maxy = INT_MIN;

    for(auto&amp; i : v)
    {
        minx = i.x() &lt; minx ? i.x() : minx;
        miny = i.y() &lt; miny ? i.y() : miny;
        maxx = i.x() &gt; maxx ? i.x() : maxx;
        maxy = i.y() &gt; maxy ? i.y() : maxy;
    }
    
    for(int i = minx; i &lt;= maxx; i++)
    {
        for(int j = miny; j &lt;= maxy; j++)
        {
            float x = i + 0.5f;
            float y = j + 0.5f;

            if(insideTriangle(x, y, t.v))
            {
                auto[alpha, beta, gamma] = computeBarycentric2D(x, y, t.v);
                float w_reciprocal = 1.0/(alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w());
                float z_interpolated = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w();
                z_interpolated *= w_reciprocal;
                
                int index = get_index(i, j);
                if(z_interpolated &lt; depth_buf[index])
                {
                    depth_buf[index] = z_interpolated;
                    set_pixel(Eigen::Vector3f(i, j, z_interpolated), t.getColor());
                }
            }
        }
    }
}
```。</description><guid isPermaLink="true">https://SDJJin1.github.io/post/GAMES101%20hw2.html</guid><pubDate>Thu, 22 Jan 2026 13:25:30 +0000</pubDate></item><item><title>GAMES101 hw1</title><link>https://SDJJin1.github.io/post/GAMES101%20hw1.html</link><description>根据课上讲的求模型矩阵的方法

&lt;img width='999' height='654' alt='Image' src='https://github.com/user-attachments/assets/66c8a127-94f3-4214-9559-352d19a612f4' /&gt;

``` c++
Eigen::Matrix4f get_model_matrix(float rotation_angle)
{
    Eigen::Matrix4f model = Eigen::Matrix4f::Identity();
    float arc1 = rotation_angle / 180.0 * acos(-1);
    model &lt;&lt; std::cos(arc1), -std::sin(arc1), 0, 0,
            std::sin(arc1), std::cos(arc1), 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1;

    return model;
}
```

要求投影矩阵，就要先得到正交矩阵，然后挤压成投影矩阵

&lt;img width='1252' height='819' alt='Image' src='https://github.com/user-attachments/assets/74ec068e-2a5c-485f-9915-67671bb788ea' /&gt;

求正交矩阵的方法

&lt;img width='1132' height='751' alt='Image' src='https://github.com/user-attachments/assets/c9abdbb9-46a1-4245-930e-9a55006aa629' /&gt;

由正交矩阵挤压成投影矩阵

&lt;img width='343' height='146' alt='Image' src='https://github.com/user-attachments/assets/ae19a871-24a7-46db-a9c3-335e8ae47138' /&gt;

再由fov求其他参数

&lt;img width='971' height='548' alt='Image' src='https://github.com/user-attachments/assets/65d17868-4d03-4e7c-b506-da25c6fdf0ba' /&gt;

``` c++
Eigen::Matrix4f get_projection_matrix(float eye_fov, float aspect_ratio,
                                      float zNear, float zFar)
{
    Eigen::Matrix4f projection = Eigen::Matrix4f::Identity();

    float t = std::tan(eye_fov) * std::abs(zNear);
    float b = t * -1;
    float r = aspect_ratio * t;
    float l = r * -1;

    Eigen::Matrix4f ortho;
    ortho &lt;&lt; 2/ (r - l), 0, 0, 0,
            0, 2/ (t - b), 0, 0,
            0, 0, 2/ (zNear - zFar), 0,
            0, 0, 0, 1;

    Eigen::Matrix4f x;
    x &lt;&lt; 1, 0, 0, -((r + l) / 2),
        0, 1, 0, -((t + b) / 2),
        0, 0, 1, -((zNear + zFar)),
        0, 0, 0, 1;
    
    ortho = ortho * x;

    Eigen::Matrix4f persp;
    persp &lt;&lt; zNear, 0, 0, 0,
            0, zNear, 0, 0,
            0, 0, zNear, -1 * zNear * zFar,
            0, 0, 1, 0;

    projection = ortho * persp;

    return projection;
}
```。</description><guid isPermaLink="true">https://SDJJin1.github.io/post/GAMES101%20hw1.html</guid><pubDate>Wed, 21 Jan 2026 13:54:37 +0000</pubDate></item><item><title>GAMES101 hw0</title><link>https://SDJJin1.github.io/post/GAMES101%20hw0.html</link><description>照题目模拟即可
``` c++
#include&lt;cmath&gt;
#include&lt;eigen3/Eigen/Core&gt;
#include&lt;eigen3/Eigen/Dense&gt;
#include&lt;iostream&gt;

int main(){
    float arc1 = 45.0 / 180.0 * acos(-1);
    Eigen::Vector3f ans(2.0, 1.0, 1.0);
    Eigen::Matrix3f Rot;
    Rot &lt;&lt; std::cos(arc1), std::sin(-arc1), 0,
            std::sin(arc1), std::cos(arc1), 0,
            0, 0, 1;
    ans = Rot * ans;
    Eigen::Matrix3f Trans;
    Trans &lt;&lt; 1.0, 0.0, 1.0,
            0.0, 1.0, 2.0,
            0.0, 0.0, 1.0;
    ans = Trans * ans;
    std::cout &lt;&lt; ans &lt;&lt; std::endl;

    return 0;
}
```。</description><guid isPermaLink="true">https://SDJJin1.github.io/post/GAMES101%20hw0.html</guid><pubDate>Wed, 21 Jan 2026 13:15:18 +0000</pubDate></item><item><title>Test</title><link>https://SDJJin1.github.io/post/Test.html</link><description>Hello World。</description><guid isPermaLink="true">https://SDJJin1.github.io/post/Test.html</guid><pubDate>Thu, 04 Dec 2025 15:33:21 +0000</pubDate></item></channel></rss>