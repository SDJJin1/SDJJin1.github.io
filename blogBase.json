{"singlePage": [], "startSite": "", "filingNum": "", "onePageListNum": 15, "commentLabelColor": "#006b75", "yearColorList": ["#bc4c00", "#0969da", "#1f883d", "#A333D0"], "i18n": "CN", "themeMode": "manual", "dayTheme": "light", "nightTheme": "dark", "urlMode": "pinyin", "script": "", "style": "", "head": "", "indexScript": "", "indexStyle": "", "bottomText": "", "showPostSource": 1, "iconList": {}, "UTC": 8, "rssSplit": "sentence", "exlink": {}, "needComment": 1, "allHead": "", "title": "Blog Title", "subTitle": "Blog description", "avatarUrl": "https://github.githubassets.com/favicons/favicon.svg", "GMEEK_VERSION": "last", "postListJson": {"P1": {"htmlDir": "docs/post/Test.html", "labels": ["documentation"], "postTitle": "Test", "postUrl": "post/Test.html", "postSourceUrl": "https://github.com/SDJJin1/SDJJin1.github.io/issues/1", "commentNum": 0, "wordCount": 11, "description": "Hello World\u3002", "top": 0, "createdAt": 1764862401, "style": "", "script": "", "head": "", "ogImage": "https://github.githubassets.com/favicons/favicon.svg", "createdDate": "2025-12-04", "dateLabelColor": "#0969da"}, "P2": {"htmlDir": "docs/post/GAMES101 hw0.html", "labels": ["Games101"], "postTitle": "GAMES101 hw0", "postUrl": "post/GAMES101%20hw0.html", "postSourceUrl": "https://github.com/SDJJin1/SDJJin1.github.io/issues/2", "commentNum": 0, "wordCount": 551, "description": "\u7167\u9898\u76ee\u6a21\u62df\u5373\u53ef\n``` c++\n#include<cmath>\n#include<eigen3/Eigen/Core>\n#include<eigen3/Eigen/Dense>\n#include<iostream>\n\nint main(){\n    float arc1 = 45.0 / 180.0 * acos(-1);\n    Eigen::Vector3f ans(2.0, 1.0, 1.0);\n    Eigen::Matrix3f Rot;\n    Rot << std::cos(arc1), std::sin(-arc1), 0,\n            std::sin(arc1), std::cos(arc1), 0,\n            0, 0, 1;\n    ans = Rot * ans;\n    Eigen::Matrix3f Trans;\n    Trans << 1.0, 0.0, 1.0,\n            0.0, 1.0, 2.0,\n            0.0, 0.0, 1.0;\n    ans = Trans * ans;\n    std::cout << ans << std::endl;\n\n    return 0;\n}\n```\u3002", "top": 0, "createdAt": 1769001318, "style": "", "script": "", "head": "", "ogImage": "https://github.githubassets.com/favicons/favicon.svg", "createdDate": "2026-01-21", "dateLabelColor": "#1f883d"}, "P3": {"htmlDir": "docs/post/GAMES101 hw1.html", "labels": ["Games101"], "postTitle": "GAMES101 hw1", "postUrl": "post/GAMES101%20hw1.html", "postSourceUrl": "https://github.com/SDJJin1/SDJJin1.github.io/issues/3", "commentNum": 0, "wordCount": 1977, "description": "\u6839\u636e\u8bfe\u4e0a\u8bb2\u7684\u6c42\u6a21\u578b\u77e9\u9635\u7684\u65b9\u6cd5\n\n<img width='999' height='654' alt='Image' src='https://github.com/user-attachments/assets/66c8a127-94f3-4214-9559-352d19a612f4' />\n\n``` c++\nEigen::Matrix4f get_model_matrix(float rotation_angle)\n{\n    Eigen::Matrix4f model = Eigen::Matrix4f::Identity();\n    float arc1 = rotation_angle / 180.0 * acos(-1);\n    model << std::cos(arc1), -std::sin(arc1), 0, 0,\n            std::sin(arc1), std::cos(arc1), 0, 0,\n            0, 0, 1, 0,\n            0, 0, 0, 1;\n\n    return model;\n}\n```\n\n\u8981\u6c42\u6295\u5f71\u77e9\u9635\uff0c\u5c31\u8981\u5148\u5f97\u5230\u6b63\u4ea4\u77e9\u9635\uff0c\u7136\u540e\u6324\u538b\u6210\u6295\u5f71\u77e9\u9635\n\n<img width='1252' height='819' alt='Image' src='https://github.com/user-attachments/assets/74ec068e-2a5c-485f-9915-67671bb788ea' />\n\n\u6c42\u6b63\u4ea4\u77e9\u9635\u7684\u65b9\u6cd5\n\n<img width='1132' height='751' alt='Image' src='https://github.com/user-attachments/assets/c9abdbb9-46a1-4245-930e-9a55006aa629' />\n\n\u7531\u6b63\u4ea4\u77e9\u9635\u6324\u538b\u6210\u6295\u5f71\u77e9\u9635\n\n<img width='343' height='146' alt='Image' src='https://github.com/user-attachments/assets/ae19a871-24a7-46db-a9c3-335e8ae47138' />\n\n\u518d\u7531fov\u6c42\u5176\u4ed6\u53c2\u6570\n\n<img width='971' height='548' alt='Image' src='https://github.com/user-attachments/assets/65d17868-4d03-4e7c-b506-da25c6fdf0ba' />\n\n``` c++\nEigen::Matrix4f get_projection_matrix(float eye_fov, float aspect_ratio,\n                                      float zNear, float zFar)\n{\n    Eigen::Matrix4f projection = Eigen::Matrix4f::Identity();\n\n    float t = std::tan(eye_fov) * std::abs(zNear);\n    float b = t * -1;\n    float r = aspect_ratio * t;\n    float l = r * -1;\n\n    Eigen::Matrix4f ortho;\n    ortho << 2/ (r - l), 0, 0, 0,\n            0, 2/ (t - b), 0, 0,\n            0, 0, 2/ (zNear - zFar), 0,\n            0, 0, 0, 1;\n\n    Eigen::Matrix4f x;\n    x << 1, 0, 0, -((r + l) / 2),\n        0, 1, 0, -((t + b) / 2),\n        0, 0, 1, -((zNear + zFar)),\n        0, 0, 0, 1;\n    \n    ortho = ortho * x;\n\n    Eigen::Matrix4f persp;\n    persp << zNear, 0, 0, 0,\n            0, zNear, 0, 0,\n            0, 0, zNear, -1 * zNear * zFar,\n            0, 0, 1, 0;\n\n    projection = ortho * persp;\n\n    return projection;\n}\n```\u3002", "top": 0, "createdAt": 1769003677, "style": "", "script": "", "head": "", "ogImage": "https://github.githubassets.com/favicons/favicon.svg", "createdDate": "2026-01-21", "dateLabelColor": "#1f883d"}, "P4": {"htmlDir": "docs/post/GAMES101 hw2.html", "labels": ["Games101"], "postTitle": "GAMES101 hw2", "postUrl": "post/GAMES101%20hw2.html", "postSourceUrl": "https://github.com/SDJJin1/SDJJin1.github.io/issues/4", "commentNum": 0, "wordCount": 2029, "description": "\u9996\u5148\u8981\u5224\u65ad\u70b9\u5728\u4e09\u89d2\u5f62\u5185\n\n<img width='762' height='480' alt='Image' src='https://github.com/user-attachments/assets/9396a6dd-1e88-4825-b61a-06609b5e890a' />\n\n``` c++\nstatic bool sameSide(Vector3f p, Vector3f a, Vector3f b, Vector3f c)\n{\n    Vector3f ab = b - a;\n    Vector3f ac = c - a;\n    Vector3f ap = p - a;\n    return (ab.cross(ac)).dot(ab.cross(ap)) >= 0;\n}\n\n\nstatic bool insideTriangle(int x, int y, const Vector3f* _v)\n{   \n    Vector3f p = {x, y, 1};\n\n    return sameSide(p, _v[0], _v[1], _v[2]) &&\n           sameSide(p, _v[1], _v[2], _v[0]) &&\n           sameSide(p, _v[2], _v[0], _v[1]);\n\n}\n```\n\n<img width='780' height='478' alt='Image' src='https://github.com/user-attachments/assets/902607b6-b3cb-4ef1-9810-aad9c87a159c' />\n\n``` c++\nvoid rst::rasterizer::rasterize_triangle(const Triangle& t) {\n    auto v = t.toVector4();\n\n    int minx = INT_MAX;\n    int maxx = INT_MIN;\n    int miny = INT_MAX;\n    int maxy = INT_MIN;\n\n    for(auto& i : v)\n    {\n        minx = i.x() < minx ? i.x() : minx;\n        miny = i.y() < miny ? i.y() : miny;\n        maxx = i.x() > maxx ? i.x() : maxx;\n        maxy = i.y() > maxy ? i.y() : maxy;\n    }\n    \n    for(int i = minx; i <= maxx; i++)\n    {\n        for(int j = miny; j <= maxy; j++)\n        {\n            float x = i + 0.5f;\n            float y = j + 0.5f;\n\n            if(insideTriangle(x, y, t.v))\n            {\n                auto[alpha, beta, gamma] = computeBarycentric2D(x, y, t.v);\n                float w_reciprocal = 1.0/(alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w());\n                float z_interpolated = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w();\n                z_interpolated *= w_reciprocal;\n                \n                int index = get_index(i, j);\n                if(z_interpolated < depth_buf[index])\n                {\n                    depth_buf[index] = z_interpolated;\n                    set_pixel(Eigen::Vector3f(i, j, z_interpolated), t.getColor());\n                }\n            }\n        }\n    }\n}\n```\u3002", "top": 0, "createdAt": 1769088330, "style": "", "script": "", "head": "", "ogImage": "https://github.githubassets.com/favicons/favicon.svg", "createdDate": "2026-01-22", "dateLabelColor": "#1f883d"}, "P6": {"htmlDir": "docs/post/GAMES101 hw3.html", "labels": ["Games101"], "postTitle": "GAMES101 hw3", "postUrl": "post/GAMES101%20hw3.html", "postSourceUrl": "https://github.com/SDJJin1/SDJJin1.github.io/issues/6", "commentNum": 0, "wordCount": 10853, "description": "hw3\u548chw2\u5728rasterize_triangle\u51fd\u6570\u4e0a\u7684\u533a\u522b\u662f\u9700\u8981\u81ea\u5df1\u8ba1\u7b97\u63d2\u503c\n\n``` c++\nvoid rst::rasterizer::rasterize_triangle(const Triangle& t, const std::array<Eigen::Vector3f, 3>& view_pos) \n{\n    auto v = t.toVector4();\n\n    int minx = INT_MAX;\n    int maxx = INT_MIN;\n    int miny = INT_MAX;\n    int maxy = INT_MIN;\n\n    for(auto& i : v)\n    {\n        minx = i.x() < minx ? i.x() : minx;\n        miny = i.y() < miny ? i.y() : miny;\n        maxx = i.x() > maxx ? i.x() : maxx;\n        maxy = i.y() > maxy ? i.y() : maxy;\n    }\n\n    for(int i = minx; i <= maxx; i++)\n    {\n        for(int j = miny; j <= maxy; j++)\n        {\n            float x = i + 0.5f;\n            float y = j + 0.5f;\n\n            if(insideTriangle(x, y, t.v))\n            {\n                auto[alpha, beta, gamma] = computeBarycentric2D(x, y, t.v);\n                float Z = 1.0 / (alpha / v[0].w() + beta / v[1].w() + gamma/v[2].w());\n    \t\t\tfloat zp = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w();\n    \t\t    zp *= Z;\n                \n                int index = get_index(i, j);\n                if(zp < depth_buf[index])\n                {\n                    auto interpolated_color = interpolate(alpha, beta, gamma, t.color[0], t.color[1], t.color[2], 1);\n                    auto interpolated_normal = interpolate(alpha, beta, gamma, t.normal[0], t.normal[1], t.normal[2], 1).normalized();\n                    auto interpolated_texcoords = interpolate(alpha, beta, gamma, t.tex_coords[0], t.tex_coords[1], t.tex_coords[2], 1);\n    \t\t\t    auto interpolated_shadingcoords = interpolate(alpha, beta, gamma, view_pos[0], view_pos[1], view_pos[2], 1);\n                    \n                    fragment_shader_payload payload(interpolated_color, interpolated_normal.normalized(), interpolated_texcoords, texture ? &*texture : nullptr);\n                    payload.view_pos = interpolated_shadingcoords;\n\t\t\t  depth_buf[index] = zp;\n                    auto pixel_color = fragment_shader(payload);\n\n                    set_pixel(Eigen::Vector2i(i, j), pixel_color);\n                }\n            }\n        }\n    }\n}\n```\n\n\u5b8c\u6210\u540e\u5c31\u53ef\u4ee5\u5f97\u5230\n\n<img width='700' height='700' alt='Image' src='https://github.com/user-attachments/assets/708b1b64-2b6d-4cc7-995f-efd79ce57af9' />\n\nBlinn-Phong\u6a21\u578b\u7684\u516c\u5f0f\n\n<img width='1003' height='633' alt='Image' src='https://github.com/user-attachments/assets/a78e832d-0622-47b5-a728-3a2e3745d473' />\n\n``` c++\nEigen::Vector3f phong_fragment_shader(const fragment_shader_payload& payload)\n{\n    Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005);\n    Eigen::Vector3f kd = payload.color;\n    Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937);\n\n    auto l1 = light{{20, 20, 20}, {500, 500, 500}};\n    auto l2 = light{{-20, 20, 0}, {500, 500, 500}};\n\n    std::vector<light> lights = {l1, l2};\n    Eigen::Vector3f amb_light_intensity{10, 10, 10};\n    Eigen::Vector3f eye_pos{0, 0, 10};\n\n    float p = 150;\n\n    Eigen::Vector3f color = payload.color;\n    Eigen::Vector3f point = payload.view_pos;\n    Eigen::Vector3f normal = payload.normal;\n\n    Eigen::Vector3f result_color = {0, 0, 0};\n    for (auto& light : lights)\n    {\n        Eigen::Vector3f light_direction = (light.position - point).normalized();\n        Eigen::Vector3f view_direction = (eye_pos - point).normalized();\n        Eigen::Vector3f half_vector = (light_direction + view_direction).normalized();\n\n        float reflection_intensity = std::max(0.0f, half_vector.dot(normal));\n\n        float light_intensity_attenuation = (light.position - point).dot(light.position - point);\n\n        Eigen::Vector3f diffuse_reflection = kd.cwiseProduct(light.intensity / light_intensity_attenuation);\n        diffuse_reflection *= reflection_intensity;\n\n        Eigen::Vector3f high_lights = ks.cwiseProduct(light.intensity / light_intensity_attenuation);\n        high_lights *= std::pow(reflection_intensity, p);\n\n        result_color += (diffuse_reflection + high_lights);\n        \n    }\n\n    Eigen::Vector3f ambient_light_reflection = ka.cwiseProduct(amb_light_intensity);\n\n    result_color += ambient_light_reflection;\n\n    return result_color * 255.f;\n}\n```\n\u5c31\u53ef\u4ee5\u5f97\u5230\n\n<img width='700' height='700' alt='Image' src='https://github.com/user-attachments/assets/ce183f1d-4fcf-4a16-9dae-bff3e108d667' />\n\n\u6309\u9898\u76ee\u7684\u8981\u6c42\uff0c\u5c06\u7eb9\u7406\u989c\u8272\u89c6\u4e3a\u516c\u5f0f\u4e2d\u7684kd\n``` c++\nEigen::Vector3f texture_fragment_shader(const fragment_shader_payload& payload)\n{\n    Eigen::Vector3f return_color = {0, 0, 0};\n    if (payload.texture)\n    {\n     return_color = payload.texture->getColor(payload.tex_coords.x(), payload.tex_coords.y());\n\n    }\n    Eigen::Vector3f texture_color;\n    texture_color << return_color.x(), return_color.y(), return_color.z();\n\n    Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005);\n    Eigen::Vector3f kd = texture_color / 255.f;\n    Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937);\n\n    auto l1 = light{{20, 20, 20}, {500, 500, 500}};\n    auto l2 = light{{-20, 20, 0}, {500, 500, 500}};\n\n    std::vector<light> lights = {l1, l2};\n    Eigen::Vector3f amb_light_intensity{10, 10, 10};\n    Eigen::Vector3f eye_pos{0, 0, 10};\n\n    float p = 150;\n\n    Eigen::Vector3f color = texture_color;\n    Eigen::Vector3f point = payload.view_pos;\n    Eigen::Vector3f normal = payload.normal;\n\n    Eigen::Vector3f result_color = {0, 0, 0};\n\n    for (auto& light : lights)\n    {\n        Eigen::Vector3f light_direction = (light.position - point).normalized();\n        Eigen::Vector3f view_direction = (eye_pos - point).normalized();\n        Eigen::Vector3f half_vector = (light_direction + view_direction).normalized();\n\n        float reflection_intensity = std::max(0.0f, half_vector.dot(normal));\n\n        float light_intensity_attenuation = (light.position - point).dot(light.position - point);\n\n        Eigen::Vector3f diffuse_reflection = kd.cwiseProduct(light.intensity / light_intensity_attenuation);\n        diffuse_reflection *= reflection_intensity;\n\n        Eigen::Vector3f high_lights = ks.cwiseProduct(light.intensity / light_intensity_attenuation);\n        high_lights *= std::pow(reflection_intensity, p);\n\n        result_color += (diffuse_reflection + high_lights);\n    }\n        Eigen::Vector3f ambient_light_reflection = ka.cwiseProduct(amb_light_intensity);\n\n        result_color += ambient_light_reflection;\n\n    return result_color * 255.f;\n}\n```\n\n<img width='700' height='700' alt='Image' src='https://github.com/user-attachments/assets/b006f374-e3bd-4c85-84d8-f5c362f1c4e9' />\n\nbump\n``` c++\nEigen::Vector3f bump_fragment_shader(const fragment_shader_payload& payload)\n{\n    \n    Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005);\n    Eigen::Vector3f kd = payload.color;\n    Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937);\n\n    auto l1 = light{{20, 20, 20}, {500, 500, 500}};\n    auto l2 = light{{-20, 20, 0}, {500, 500, 500}};\n\n    std::vector<light> lights = {l1, l2};\n    Eigen::Vector3f amb_light_intensity{10, 10, 10};\n    Eigen::Vector3f eye_pos{0, 0, 10};\n\n    float p = 150;\n\n    Eigen::Vector3f color = payload.color; \n    Eigen::Vector3f point = payload.view_pos;\n    Eigen::Vector3f normal = payload.normal;\n\n\n    float kh = 0.2, kn = 0.1;\n\n \n    float x = normal.x();\n    float y = normal.y();\n    float z = normal.z();\n    Eigen::Vector3f t = {-x*y/sqrt(x*x+z*z),sqrt(x*x+z*z),-z*y/sqrt(x*x+z*z)};\n    Eigen::Vector3f b = normal.cross(t);\n    Eigen::Matrix3f TBN;\n    TBN << t.x(), b.x(), normal.x(), t.y(), b.y(), normal.y(), t.z(), b.z(), normal.z();\n    float u = payload.tex_coords.x();\n    float v = payload.tex_coords.y();\n    float w = payload.texture->width;\n    float h = payload.texture->height;\n    float dU = kh * kn *(payload.texture->getColor(u + 1.0 / w, v).norm() - payload.texture->getColor(u, v).norm());\n    float dV = kh * kn *(payload.texture->getColor(u, v + 1.0 / h).norm() - payload.texture->getColor(u, v).norm());\n\n    Eigen::Vector3f ln = {-dU, -dV, 1};\n    normal = (TBN * ln).normalized();\n\n    Eigen::Vector3f result_color = {0, 0, 0};\n    result_color = normal;\n\n    return result_color * 255.f;\n}\n```\n<img width='700' height='700' alt='Image' src='https://github.com/user-attachments/assets/cc0e7179-98de-41f4-bd74-f0cc7bac9d1c' />\n\ndisplacement\n``` c++\nEigen::Vector3f displacement_fragment_shader(const fragment_shader_payload& payload)\n{\n    \n    Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005);\n    Eigen::Vector3f kd = payload.color;\n    Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937);\n\n    auto l1 = light{{20, 20, 20}, {500, 500, 500}};\n    auto l2 = light{{-20, 20, 0}, {500, 500, 500}};\n\n    std::vector<light> lights = {l1, l2};\n    Eigen::Vector3f amb_light_intensity{10, 10, 10};\n    Eigen::Vector3f eye_pos{0, 0, 10};\n\n    float p = 150;\n\n    Eigen::Vector3f color = payload.color; \n    Eigen::Vector3f point = payload.view_pos;\n    Eigen::Vector3f normal = payload.normal;\n\n    float kh = 0.2, kn = 0.1;\n    \n    float x = normal.x();\n    float y = normal.y();\n    float z = normal.z();\n    Eigen::Vector3f t = {-x*y/sqrt(x*x+z*z),sqrt(x*x+z*z),-z*y/sqrt(x*x+z*z)};\n    Eigen::Vector3f b = normal.cross(t);\n    Eigen::Matrix3f TBN;\n    TBN << t.x(), b.x(), normal.x(), t.y(), b.y(), normal.y(), t.z(), b.z(), normal.z();\n    float u = payload.tex_coords.x();\n    float v = payload.tex_coords.y();\n    float w = payload.texture->width;\n    float h = payload.texture->height;\n    float dU = kh * kn *(payload.texture->getColor(u + 1.0 / w, v).norm() - payload.texture->getColor(u, v).norm());\n    float dV = kh * kn *(payload.texture->getColor(u, v + 1.0 / h).norm() - payload.texture->getColor(u, v).norm());\n\n    Eigen::Vector3f ln = {-dU, -dV, 1};\n    normal = (TBN * ln).normalized();\n\n\n    Eigen::Vector3f result_color = {0, 0, 0};\n\n    for (auto& light : lights)\n    {\n        Eigen::Vector3f light_direction = (light.position - point).normalized();\n        Eigen::Vector3f view_direction = (eye_pos - point).normalized();\n        Eigen::Vector3f half_vector = (light_direction + view_direction).normalized();\n\n        float reflection_intensity = std::max(0.0f, half_vector.dot(normal));\n\n        float light_intensity_attenuation = (light.position - point).dot(light.position - point);\n\n        Eigen::Vector3f diffuse_reflection = kd.cwiseProduct(light.intensity / light_intensity_attenuation);\n        diffuse_reflection *= reflection_intensity;\n\n        Eigen::Vector3f high_lights = ks.cwiseProduct(light.intensity / light_intensity_attenuation);\n        high_lights *= std::pow(reflection_intensity, p);\n\n        result_color += (diffuse_reflection + high_lights);\n\n\n    }\n\n    Eigen::Vector3f ambient_light_reflection = ka.cwiseProduct(amb_light_intensity);\n\n    result_color += ambient_light_reflection;\n    return result_color * 255.f;\n}\n```\n\n<img width='700' height='700' alt='Image' src='https://github.com/user-attachments/assets/88b7701e-5797-4bb2-aa3f-ee47fd00b165' />\u3002", "top": 0, "createdAt": 1769180334, "style": "", "script": "", "head": "", "ogImage": "https://github.githubassets.com/favicons/favicon.svg", "createdDate": "2026-01-23", "dateLabelColor": "#1f883d"}}, "singeListJson": {}, "labelColorDict": {"bug": "#d73a4a", "documentation": "#0075ca", "duplicate": "#cfd3d7", "enhancement": "#a2eeef", "Games101": "#df3966", "good first issue": "#7057ff", "help wanted": "#008672", "invalid": "#e4e669", "question": "#d876e3", "wontfix": "#ffffff"}, "displayTitle": "Blog Title", "faviconUrl": "https://github.githubassets.com/favicons/favicon.svg", "ogImage": "https://github.githubassets.com/favicons/favicon.svg", "primerCSS": "<link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />", "homeUrl": "https://SDJJin1.github.io", "prevUrl": "disabled", "nextUrl": "disabled"}